// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Vision.h"
#include "../RobotMap.h"
#include "../Commands/VisionUpdate.h"
#include <stdlib.h>     //for using the function sleep
#include <time.h>

#include <exception>

#include <sys/socket.h>
#include <arpa/inet.h>

#include <stdio.h>
#include <unistd.h>


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Vision::Vision() : Subsystem("Vision") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

}

void Vision::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

    	udpCOGX = 0;
    	udpCOGY = 0;
        try {
        	std::thread t(udpRcvr);			// Attempt to start thread to process incoming udp packets
        	t.detach();						// Detach which allows thread to run in background forever
        }
        catch (const std::exception& e){
        	std::cout << "Error starting thread exception: " << e.what() << std::endl;
        }
}


// Put methods for controlling this subsystem
// here. Call these from Commands.

void Vision::SetRouteSegment(int cnt, Segment seg){
	route.seg[cnt] = seg;
}

Segment Vision::GetSegment(int cnt){
	return route.seg[cnt];
}

void Vision::SetRoute(Route mroute){
	route = mroute;
}

Route Vision::GetRoute(){
	return route;
}


// ------- Setters  -------

// step 1 Calculations
void Vision::SetCOG(double mCOGX, double mCOGY){
	COGX = mCOGX;
	COGY = mCOGY;
}

void Vision::SetCurrYaw( double yaw){
	currYaw = yaw;
}

void Vision::SetTgtFlag(int mValidTgtFlag){
	validTgtFlag = mValidTgtFlag;
}

// step 2 Calculations
void Vision::SetWallDist(double mwallDist){
	 wallDist = mwallDist;
}

// step 3 Calculations
void Vision::SetTgtAngles(double mtgtAngleX, double mtgtAngleF){
	tgtAngleX = mtgtAngleX;
	tgtAngleF = mtgtAngleF;
}

void Vision::SetTgtTransCorrection(double madjTgtTransCorrection, double mtgtTransCorrection){
	adjTgtTransCorrection = madjTgtTransCorrection;
	tgtTransCorrection = mtgtTransCorrection;
}

// step 4 Calculations
void Vision::SetTipHdgDist(double hdg, double dist){
	 tipHdg = hdg;
	 tipDist = dist;
}

void Vision::SetTgtDist(double mtgtDistance){
	tgtDistance = mtgtDistance;
}

// Misc. S curve calculations not effective
void Vision::SetAngleCorrection(double correction){
	currAngleCorrection = correction;
}

void Vision::SetTipShiftData(double totDist, double hdg1, double hdg2, double fwdDist){				// pass the tip hdg and dist to vision subsystem
	shiftDist = totDist;
	shiftHdg1 = hdg1;
	shiftHdg2 = hdg2;
	shiftFwdDist = fwdDist;
}
void Vision::SetTipShiftAnlges(double angle1, double angle2){
		shiftAngle1 = angle1;
		shiftAngle2 = angle2;
}
void Vision::SetActiveWheel(double a, double b){
	shiftActiveWheelA = a;
	shiftActiveWheelB = b;
}


// ------- getters -------
int Vision::GetValidTgtFlag()	{ return validTgtFlag; }
double Vision::GetTgtDist()		{ return tgtDistance; }
double Vision::GetShiftDist()	{ return shiftDist; }
double Vision::GetWallDist()	{ return wallDist; }
double Vision::GetShiftHdg1()	{ return shiftHdg1; }
double Vision::GetShiftHdg2()	{ return shiftHdg2; }
double Vision::GetShiftAngle1()	{ return shiftAngle1; }
double Vision::GetShiftAngle2()	{ return shiftAngle2; }
double Vision::GetActiveWheelA(){ return shiftActiveWheelA; }
double Vision::GetActiveWheelB(){ return shiftActiveWheelB; }


double Vision::GetShiftFwdDist(){ return shiftFwdDist; }
double Vision::GetTgtTransCorrection()		{ return tgtTransCorrection; }
double Vision::GetAdjTgtTransCorrection()	{ return adjTgtTransCorrection; }
double Vision::GetCOGX()		{ return COGX; }
double Vision::GetCOGY()		{ return COGY; }

double Vision::GetUDPCOGX(){
	double x;
	udpMutex.lock();
	x = udpCOGX;
	udpMutex.unlock();
	return x;
}
double Vision::GetUDPCOGY(){
	double y;
	udpMutex.lock();
	y = udpCOGY;
	udpMutex.unlock();
	return y;
}

double Vision::GetTgtAngleX()		{ return tgtAngleX; }
double Vision::GetTgtAngleF()		{ return tgtAngleF; }
double Vision::GetCurrYaw()			{ return currYaw; }
double Vision::GetAngleCorrection()	{ return currAngleCorrection; }
double Vision::GetTipHdg()			{ return tipHdg; }
double Vision::GetTipDist()			{ return tipDist; }


// ------------------------------------------------------------------------
// ------------------------ Smart Dashboard Methods -----------------------
void Vision::Update_Smartdashboard(double mode){
	SmartDashboard::PutNumber("Vision COGX", COGX);
	SmartDashboard::PutNumber("Vision COGY", COGY);
	SmartDashboard::PutNumber("Vision tgtFlag", validTgtFlag);
	// Step 1
	SmartDashboard::PutNumber("Vision CurrYaw", currYaw);
	SmartDashboard::PutNumber("Vision AlignError", currAngleCorrection);
	// Step 2
	SmartDashboard::PutNumber("Vision WallDist", wallDist);
	// Step 3
	SmartDashboard::PutNumber("Vision tgtAngleX", tgtAngleX);
	SmartDashboard::PutNumber("Vision tgtAngleF", tgtAngleF);
	SmartDashboard::PutNumber("Vision  Wall Offset", tgtTransCorrection);
	// Step 4
	SmartDashboard::PutNumber("Vision TipHdg", tipHdg);
	SmartDashboard::PutNumber("Vision TipDist", tgtDistance);
}


void Vision::udpRcvr(){
	double x,y, t;				// temperary holders for COGX, COGY, time
	try {
		Robot::logger->appendLog("Starting udpRcv Thread");
		std::cout << "Starting udpRcv thread " << std::endl;

		struct sockaddr_in si_me, si_remote;
		int s, slen = sizeof(si_remote) , recv_len;
		char buf[BUFLEN];

		//create a UDP socket
		if ((s=socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1)
		{
			threadError (  "Error Starting Socket udpRcv thread  "  );
			return;
		}
		else{
			std::cout << "Socket Created OK " << std::endl;
		}

		// zero out the local socket Address structure
		memset((char *) &si_me, 0, sizeof(si_me));
		si_me.sin_family = AF_INET;
		si_me.sin_port = htons(PORT);
		si_me.sin_addr.s_addr = htonl(INADDR_ANY);

		//bind to local socket to port on any local address
		if( bind(s , (struct sockaddr*)&si_me, sizeof(si_me) ) == -1)
		{
			threadError (  "Error Starting Bind to local socket udpRcv thread  "  );
			return;
		}
		else{
			std::cout << "Bind Created OK " << std::endl;
		}
		// zero out the remote socket Address structure
		memset((char *) &si_remote, 0, sizeof(si_remote));
		si_remote.sin_family = AF_INET;
		si_remote.sin_port = htons(PORT);
		if (inet_aton(ROBORIO , &si_remote.sin_addr) == 0)
		{
			threadError ( "Error inet_aton() failed udpRcv thread  " );
			return;
		}
		else{
			std::cout << "Remote Address Created OK " << std::endl;
		}

		//keep listening for data
		while(1)
		{
		    //std::cout << "Thread waiting for data " << std::endl;

		    // ---- try to receive some data, this is a blocking call ----
		    if ((recv_len = recvfrom(s, buf, BUFLEN, 0, (struct sockaddr *) &si_remote,   (socklen_t *) &slen)) == -1)
		    {
		     		std::cout << "Error Receive From udpRcv thread  " << std::endl;
		        }
		    else{
				//std::cout	<< "Received UDP packet from " << inet_ntoa(si_remote.sin_addr) << "Received packet len=" << recv_len
				//			<< " Data buf=" << buf << ":" << std::endl;

		    	// ----- parse out cog data ------
		    	size_t pos, xpos, ypos, tpos;
		    	std::string cppbuff = buf;		// convert buffer to c++ string object
		    	if ((pos = cppbuff.find("x=")) != std::string::npos ){
		    		xpos = pos +2;
		    	}
		    	else{
		    		xpos = 0;
		    	}
		    	if ((pos = cppbuff.find("y=")) != std::string::npos ){
		    		ypos = pos +2;
		    	}
		    	else{
		    		ypos = 0;
		    	}
		    	if ((pos = cppbuff.find("t=")) != std::string::npos ){
		    		tpos = pos +2;
		    	}
		    	else{
		    		tpos = 0;
		    	}
		    	if ((xpos != 0) && ( ypos !=0)){
		    		std::string xstring = cppbuff.substr(xpos, ypos-2-xpos);
		    		x = atoi(xstring.c_str());
		    	} else {
		    		x=0;
		    	}
		    	if ((ypos != 0) && ( tpos !=0)){
		    		std::string ystring = cppbuff.substr(ypos, tpos-2-ypos);
		    		y = atoi(ystring.c_str());
		    	} else {
		    		y=0;
		    	}
		    	if (tpos != 0){

		    		std::string tstring = cppbuff.substr(tpos, (cppbuff.length()-tpos-1));
		    		t = atol(tstring.c_str());
		    	} else {
		    		t=0;
		    	}
				udpMutex.lock();
				udpCOGX = x;		// Extract COGX data from buf
				udpCOGY = y;		// Extract COGY data from buf
				udpMutex.unlock();

				//std::cout << "udpCOGX=" << udpCOGX << "   udpCOGY=" << udpCOGY << "   t=" << t << std::endl;
				//std::this_thread::sleep_for(std::chrono::milliseconds(5000));
		    }
		}	// end of While will never get past this point (loops forever)
		close(s);

	}
	catch (const std::exception& e) {	// Error in thread startup
		std::cout << "Error in thread exception 1 : e.what=" << e.what();
		threadError ("");
		return;
	}
	catch (...) {
		threadError ("Error in Thread exception 2");
		return;
	}
}

void Vision::threadError(std::string errMsg){
	std::cout << errMsg << std::endl;
	udpMutex.lock();
	udpCOGX = 0;
	udpCOGY = 0;
	udpMutex.unlock();
}


