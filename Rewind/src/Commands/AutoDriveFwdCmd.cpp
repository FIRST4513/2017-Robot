// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "AutoDriveFwdCmd.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

AutoDriveFwdCmd::AutoDriveFwdCmd(double tgtDist, double accelPwr, double cruisePwr, double decelPwr, double slowPwr, double stopPwr, double accelDist, double decelDist, double slowSpeed, double stopDist, int TO, int Mode): Command() {
    m_tgtDist = tgtDist;
    m_accelPwr = accelPwr;
    m_cruisePwr = cruisePwr;
    m_decelPwr = decelPwr;
    m_slowPwr = slowPwr;
    m_stopPwr = stopPwr;
    m_accelDist = accelDist;
    m_decelDist = decelDist;
    m_slowSpeed = slowSpeed;
    m_stopDist = stopDist;
    m_TO = TO;
    m_Mode = Mode;
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::drivetrain.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void AutoDriveFwdCmd::Initialize() {
	line = "Debug, Drivetrain, ********** Starting AutoDriveFwdCmd ***********";
	line += " Speed=" + std::to_string(m_cruisePwr) + " Dist=" + std::to_string(m_tgtDist);
	line += " TimeOut=" + std::to_string(m_TO);
	Robot::logger->appendLog(line);
	std::cout << "AutoDriveFwdCmd Init" << std::endl;

	SetTimeout(m_TO);


	Robot::drivetrain->ResetEncoders();
	Robot::drivetrain->SetFirstTimeFlag(0);					// set flag to zero for gyro correction
	if (m_tgtDist < 0) m_tgtDist = m_tgtDist * -1;			// Distance is always positive, speed can be negative
	m_RemainTgtDist = m_tgtDist;

	motionFlag = 0;											// false=NO motion yet, true=Motion has begun
	stopFlag = 0;											// Clear stop flag to start
	driveModeFlag = 0;										// We are just starting out will need to accel.

	if (m_Mode == 1){
		// Mode 1 = Look up vision data to make sure we had a valid target to drive up to.
		//double corr = Robot::vision->GetAdjTgtTransCorrection();
		int validTgtFlag = Robot::vision->GetValidTgtFlag();

		if (validTgtFlag == 0){								// we dont have valid target in view
			Robot::logger->appendLog("No Vision target in sight aborting autodriveFwdCmd!");
			driveModeFlag = 6;								// so exit
		}
		tgtHdg = Robot::vision->GetTipHdg();
		//if ((validTgtFlag == 1) && ((corr > +3.5) || (corr < -3.5))) {
		//	driveModeFlag = 6;								// correction beyond range so exit
		//}
	}
}

// Called repeatedly when this Command is scheduled to run
void AutoDriveFwdCmd::Execute() {
	// ---- Look up key data to start ----
	currDist = Robot::drivetrain->GetAverageDist();
	currSpeed = Robot::drivetrain->GetAverageSpeed();
	m_RemainTgtDist = m_tgtDist - currDist;

	// ----- State 0 (Initial Stop State) -----
	if (driveModeFlag == 0){
		// were starting to accelerate
		driveModeFlag = 1;
		Robot::logger->appendLog("We are starting to acelerate up to speed   (autoDriveFwdCmd) !");
		if (m_cruisePwr < m_accelPwr) {
			currPwr = m_cruisePwr; }
		else {
			currPwr = m_accelPwr; }
	}

	// ----- State 1 (Accel State) we are accelerating at begining -----
	if (driveModeFlag == 1){
		if (currSpeed > 0) motionFlag = true;	// we have started moving
		// Have we reached the point to change to cruise state
		if (currDist > m_accelDist){
			Robot::logger->appendLog("We have reached speed starting to cruise  (autoDriveFwdCmd) !");
			driveModeFlag = 2;
			currPwr =  m_cruisePwr; }
	}

	// ----- State 2 (Cruise State) We are cruising down the road now -----
	if (driveModeFlag == 2){
		// Have we reached the point we need to decelerate to slow speed?
		if (m_RemainTgtDist <= m_decelDist){
			Robot::logger->appendLog("We are starting to Decelerate to Slow speed   (autoDriveFwdCmd) !");
			driveModeFlag = 3;
			currPwr =  m_decelPwr; }
	}

	// ----- State 3 (Decel State) We are decelerating down to the slow speed before braking -----
	if (driveModeFlag == 3){
		// Have we reached decelerated to the slow Speed (10 inches per sec.)
		if (currSpeed <= 10){
			Robot::logger->appendLog("We have reached Slow speed   (autoDriveFwdCmd) !");
			driveModeFlag = 4;
			currPwr =  m_slowPwr; }
	}

	// ----- State 4 (Slow speed State) -----
	if (driveModeFlag == 4){
		// Have we reached the point we need to start braking to a stop
		if (m_RemainTgtDist <= m_stopDist){
			Robot::logger->appendLog("We have rached Brake point starting to brake  (autoDriveFwdCmd) !");
			driveModeFlag = 5;
			currPwr =  m_stopPwr; }
	}

	// ----- Check to see if we have gone too far and State 5 (Brake State) -----
	if (m_RemainTgtDist <= 0){
		if (stopFlag == 0){
			std::cout << "  We may have over run target DISTANCE" << std::endl;
			Robot::logger->appendLog("We have over run target need to Brake   (autoDriveFwdCmd) !");
		}
		driveModeFlag = 5;		// we need to brake
	}

	// ----- Check to see if we have hit the probe and need to Brake -----
	if (Robot::drivetrain->GetProbeLmtSw() != true){
		if (stopFlag == 0){
			std::cout << "Probe switch has been hit" << std::endl;
			Robot::logger->appendLog("We have hit probe need to Brake   (autoDriveFwdCmd) !");
		}
		driveModeFlag = 5;
	}


	// ----- State 5 (Brake State) -----
	if (driveModeFlag == 5) {
		stopFlag = 1;
		if (Robot::drivetrain->GetAverageSpeed() > 0){
			// we are still moving forward continue braking
			Robot::drivetrain->TankDrive(-0.3, -0.2);
		}
		else {
			// we have finally stopped so were all done
			driveModeFlag = 6;
			std::cout << "We have stopped" << std::endl;
			Robot::logger->appendLog("We were braking and have now stopped  (autoDriveFwdCmd) !");
		}
	}

	Robot::drivetrain->PutZoneData( 8, 0, m_tgtDist, m_RemainTgtDist, currPwr);
	if (driveModeFlag != 5){
		// we are not in brake mode so send pwr to drivetrain
		SendPwrToDrivetrain( currPwr, 1);
	}
	return;
}


// Make this return true when this Command no longer needs to run execute()
bool AutoDriveFwdCmd::IsFinished() {
	if (IsTimedOut()) return true;				// used in all modes

	if (driveModeFlag == 6) return true; 		// No valid target detected, or have stopped so exit

	if ( (currSpeed <= 0) && (motionFlag == true )){
		// Make sure we are past the slow start, end when stopped
		Robot::logger->appendLog("We have stopped   (autoDriveFwdCmd) !");
		std::cout << "We have stopped" << std::endl;
		return true;		// we have stopped so end
	}

	 return false;
}

// Called once after isFinished returns true
void AutoDriveFwdCmd::End() {
	Robot::drivetrain->StopMtrs();							// stop the motors
	Robot::logger->appendLog("**** Ending AutoFwdCmd *****");
	std::cout << "AutoFwdCmd End" << std::endl;
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void AutoDriveFwdCmd::Interrupted() {
	End();
}

void AutoDriveFwdCmd::SendPwrToDrivetrain(double speed, int mode){
	//if (mode==0) Robot::drivetrain->TankDrive(speed, speed);

	if (m_Mode==0){
		Robot::drivetrain->Drive(speed, 0);
	} else {
		// OK to cintune driving forward
		Robot::drivetrain->SetFirstTimeFlag(0);					// set flag to zero for gyro correction
		Robot::drivetrain->DriveToHdg(speed,tgtHdg);
	}
}

