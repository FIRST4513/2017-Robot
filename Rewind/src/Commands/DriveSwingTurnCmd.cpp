// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "DriveSwingTurnCmd.h"
//#include "../Robot.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

DriveSwingTurnCmd::DriveSwingTurnCmd(double LftSpeed, double RtSpeed, double Radius, double Timeout, double Mode, double Angle): Command() {
    m_LftSpeed = LftSpeed;
    m_RtSpeed = RtSpeed;
    m_Radius = Radius;
    m_Timeout = Timeout;
    m_Mode = Mode;
    m_Angle = Angle;
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::drivetrain.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR



// Called just before this Command runs the first time
void DriveSwingTurnCmd::Initialize() {
	SetTimeout(m_Timeout);
	line = "Debug, Drivetrain, Starting DriveSwingTurnCmd,";
	Robot::logger->appendLog(line);

	pdp = new PowerDistributionPanel();
	beginHdg = Robot::drivetrain->GetGyroHeading();
	beginYaw = Robot::drivetrain->GetGyroYaw();
	Robot::drivetrain->ResetEncoders();
	Robot::drivetrain->SetFirstTimeFlag(0);						// set flag to zero for gyro correction
	state = 0;													// Initial State
	turnDir = 0;												// 0 = straight, 1= RightTurn, -1=Left Turn
	remainAngle = 0;
	currPwr = 0;

	if (m_Mode == 0){
		initMode0();
		return;
	}
	if (m_Mode == 1){
		initMode1();
	}
	if (m_Mode == 2){
		initMode2();
	}

	// ---- Check for no angle or too small an angle to perform ----
	if (m_Angle == 0){		// **** maybe exit if angle +- 0.5 degrees ?????? ie) too small to attempt
		state = 6;											// get out invalid data
		std::cout << "No Swing Turn Needed!" << std::endl;
		Robot::logger->appendLog("Mode 1or2 - No Swing Turn Needed!");
		return;
	}
	endHdg = AddAngleToHdg( beginHdg, m_Angle);
}

// Called repeatedly when this Command is scheduled to run
void DriveSwingTurnCmd::Execute() {
	// state 0= We have'nt started moving yet
	// state 1= Were now moving
	// state 2= Reached slow distance to target angle
	// state 3= Reached endHdg applying brakes
	// state 6= Time To exit

	currHdg = Robot::drivetrain->GetGyroHeading();
	currYaw = Robot::drivetrain->GetGyroYaw();
	remainAngle = CalcRemainAngle(currHdg, endHdg);
	logModeData();

	if (state == 0){
		currPwr = TURNSPEED;
		if ((activeWheel < 0) && (Robot::drivetrain->GetLeftSpeed() != 0)){
			state = 1;		// We have started to move
			Robot::logger->appendLog("We have started to move left wheels!");
		}
		if ((activeWheel > 0) && (Robot::drivetrain->GetRightSpeed() != 0)){
			state = 1;		// We have started to move
			Robot::logger->appendLog("We have started to move left wheels!");
		}
	}

	if (state == 1){
		// we are in active turn mode
		currPwr=TURNSPEED;
		// ---- Check if we have reached our slow speed spot or brake spot
		checkForSlow();
		checkForBrake();
	}

	if (state == 2){
		// we are in slow turn mode
		checkForBrake();
	}


	if (state > 0){
		if (checkForStopped() == true) {
			state = 6;
			Robot::logger->appendLog("The driving wheels have stopped!");
			return;
		}
	}
	sendPwrOut(currPwr);
}


// --------------------------------------------------------------------------
//                               End Routines
// --------------------------------------------------------------------------

// Make this return true when this Command no longer needs to run execute()
bool DriveSwingTurnCmd::IsFinished() {
	if (IsTimedOut()){
		std::cout << "Drive Swing Turn CMD Timed OUT !" << std::endl;
		Robot::logger->appendLog("Drive Swing Turn Cmd Has Timed Out");
		return true;
	}

	if (state == 6) {
		return true;
	}

    return false;
}

// Called once after isFinished returns true
void DriveSwingTurnCmd::End() {
	Robot::logger->appendLog("Drive Swing Turn Cmd Has Ended!");
	Robot::drivetrain->StopMtrs();
	Robot::drivetrain->Update_Smartdashboard(0);
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void DriveSwingTurnCmd::Interrupted() {
	End();
}



// --------------------------------------------------------------------------
//                      Init Routines
// --------------------------------------------------------------------------
void DriveSwingTurnCmd::initMode0(){
	// -- Follow turn by parameters no Vision component
	if (m_Angle > 0) {
		// Right CW Turn
		Robot::logger->appendLog("Mode 0 - Right Turn");
		turnDir = +1;
		activeWheel = -1;									// Left wheel active for this Right turn
	} else {
		// Left CCW Turn
		Robot::logger->appendLog("Mode 0 - Right Turn");
		turnDir = -1;
		activeWheel = +1;									// Right wheel active for this Left turn
	}
	endHdg = AddAngleToHdg( beginHdg, m_Angle );
	line = "Debug, Swingturn, Mode 0 BeginHdg = ," + std::to_string(beginHdg);
	line += "EndHdg = ," + std::to_string(endHdg);
	line += "Angle = ," + std::to_string(m_Angle);
	Robot::logger->appendLog(line);
}

void DriveSwingTurnCmd::initMode1(){
	// ---- Get Angle and active wheel for Modes 1 or 2 ----
	m_Angle = Robot::vision->GetShiftAngle1();
	hdg1 = Robot::vision->GetShiftHdg1();
	hdg2 = Robot::vision->GetShiftHdg2();
	ang1 = Robot::vision->GetShiftAngle1();
	ang2 = Robot::vision->GetShiftAngle2();
	shiftD = Robot::vision->GetShiftDist();

	if (Robot::vision->GetActiveWheelA() < 0) {
		 activeWheel = -1; 									// left wheel active
	} else {
		activeWheel = +1;									// Right wheel
	}
	if (m_Angle < 0)										// Left CCW Turn
		turnDir = -1;
	else													// Right CW Turn
		turnDir = 1;

	line = "Debug, Swing turn, Init Mode 1 BeginHdg = ," + std::to_string(beginHdg);
	line += "Timeout = ," + std::to_string(m_Timeout);
	line += "EndHdg = ," + std::to_string(endHdg);
	line += "BegHdg = ," + std::to_string(beginHdg);
	line += "m_Angle = ," + std::to_string(m_Angle);
	line += "Ang1 = ," + std::to_string(ang1);
	line += "Hdg1 = ," + std::to_string(hdg1);
	line += "Ang2 = ," + std::to_string(ang2);
	line += "Hdg2 = ," + std::to_string(hdg2);
	line += "ShiftD = ," + std::to_string(shiftD);
	Robot::logger->appendLog(line);
}

void DriveSwingTurnCmd::initMode2(){
	// ---- Get Angle and active wheel for Modes 1 or 2 ----
	m_Angle = Robot::vision->GetShiftAngle2();
	hdg1 = Robot::vision->GetShiftHdg1();
	hdg2 = Robot::vision->GetShiftHdg2();
	ang1 = Robot::vision->GetShiftAngle1();
	ang2 = Robot::vision->GetShiftAngle2();
	shiftD = Robot::vision->GetShiftDist();

	if (Robot::vision->GetActiveWheelB() < 0) {
		 activeWheel = -1; 									// left wheel active
	} else {
		activeWheel = +1;									// Right wheel
	}
	if (m_Angle < 0)										// Left CCW Turn
		turnDir = -1;
	else													// Right CW Turn
		turnDir = 1;

	line = "Debug, Swing turn, Init Mode 2 BeginHdg = ," + std::to_string(beginHdg);
	line += "Timeout = ," + std::to_string(m_Timeout);
	line += "EndHdg = ," + std::to_string(endHdg);
	line += "BegHdg = ," + std::to_string(beginHdg);
	line += "m_Angle = ," + std::to_string(m_Angle);
	line += "Ang1 = ," + std::to_string(ang1);
	line += "Hdg1 = ," + std::to_string(hdg1);
	line += "Ang2 = ," + std::to_string(ang2);
	line += "Hdg2 = ," + std::to_string(hdg2);
	line += "ShiftD = ," + std::to_string(shiftD);
	Robot::logger->appendLog(line);
}

void DriveSwingTurnCmd::logModeData(){
	line = "Debug, DriveSwingTurnCmd LogMode data,";
	line += " state=" + std::to_string(state);
	line += " beginHdg = " + std::to_string(beginHdg);
	line += " EndHdg=" + std::to_string(endHdg);
	line += " CurrHdg=" + std::to_string(currHdg);
	line += " CurrYaw=" + std::to_string(currYaw);
	line += " remainAngle=" + std::to_string(remainAngle);
	line += " Angle=" + std::to_string(m_Angle);
	line += " currPwr=" + std::to_string(currPwr);
	line += " Lf Speed=" + std::to_string(Robot::drivetrain->GetLeftSpeed());
	line += " Rt Speed=" + std::to_string(Robot::drivetrain->GetRightSpeed());

	line += " FrontLftPwr=" + std::to_string( pdp->GetCurrent(12));
	line += " RearLeftPwr=" + std::to_string( pdp->GetCurrent(14));
	line += " FrontRightPwr=" + std::to_string( pdp->GetCurrent(15));
	line += " RearRightPwr=" + std::to_string( pdp->GetCurrent(13));
	Robot::logger->appendLog(line);
}


// --------------------------------------------------------------------------
//
// --------------------------------------------------------------------------
void DriveSwingTurnCmd::sendPwrOut(double pwr){
	if ( state == 3){
		// were in brake mode send pwr as defined straight out to motors and return
		if (activeWheel < 0){
			Robot::logger->appendLog("SendPwrOut:state 3 braking active wheel Left pwr =" + std::to_string(pwr));
			Robot::drivetrain->TankDrive( +pwr ,-HOLDPWR );
		} else {
			Robot::logger->appendLog("SendPwrOut:state 3 braking active wheel Right pwr =" + std::to_string(pwr));
			Robot::drivetrain->TankDrive( -HOLDPWR , +pwr );
		}
		return;
	}

	// were in turn mode send pwr to motors as needed by direction
	if (activeWheel < 0) {
		// Left wheel is driving
		if (turnDir < 0){
			Robot::logger->appendLog("SendPwrOut:State Not 3 active wheel Left Reverse Direction pwr =" + std::to_string(pwr));
			Robot::drivetrain->TankDrive( -pwr , +HOLDPWR );
		} else {
			Robot::logger->appendLog("SendPwrOut:State Not 3 active wheel Left Forward Direction pwr =" + std::to_string(pwr));
			Robot::drivetrain->TankDrive( +pwr , -HOLDPWR );
		}
	} else {
		// Right Wheel is driving
		if (turnDir < 0){
			Robot::logger->appendLog("SendPwrOut:State Not 3 active wheel Right Forward Direction pwr =" + std::to_string(pwr));
			Robot::drivetrain->TankDrive( -HOLDPWR , +pwr );
		} else {
			Robot::logger->appendLog("SendPwrOut:State Not 3 active wheel Right Reverse Direction pwr =" + std::to_string(pwr));
			Robot::drivetrain->TankDrive( +HOLDPWR , -pwr );
		}
	}
	//Robot::drivetrain->Update_Smartdashboard(0);
}

// ------------------ Check for Slow ---------------------------
void DriveSwingTurnCmd::checkForSlow(){
	if (((turnDir > 0 ) && (remainAngle <= +SLOWANGLE)) ||
		((turnDir < 0 ) && (remainAngle >= -SLOWANGLE))) {
			// its time time to slow down
			state = 2;
			currPwr = SLOWSPEED;
			line = "We have reached Slow dest. angle slow down currHdg=" + std::to_string(currHdg) + "state=" + std::to_string(state);
			Robot::logger->appendLog(line);
	}
}


// ------------------ Check for Brake ---------------------------
void DriveSwingTurnCmd::checkForBrake(){
	if (((turnDir > 0 ) && (remainAngle <= +OVERSHOOT)) ||
		((turnDir < 0 ) && (remainAngle >= -OVERSHOOT))) {
			// its time to brake
			state = 3;
			if (activeWheel < 0){
				// Left wheel is active
				if (turnDir < 0){
					// Left wheel was rotating reverse
					currPwr = +LFTBRAKEPWR;
				} else {
					currPwr = -LFTBRAKEPWR;
				}
			} else {
				// Right wheel is active
				if (turnDir < 0){
					// Right wheel was rotating forward
					currPwr = -RTBRAKEPWR;
				} else {
					currPwr = +RTBRAKEPWR;
				}
			}
			line = "We have reached brake Angle start braking currHdg=" + std::to_string(currHdg) + "state=" + std::to_string(state);
			Robot::logger->appendLog(line);
	}
}

// ------------------ Check for Stopped ---------------------------
bool DriveSwingTurnCmd::checkForStopped(){
	// Check if we have stopped or reversed direction of wheel
	if (activeWheel < 0){
		// Left motor active
		if ((turnDir < 0) && (Robot::drivetrain->GetLeftSpeed() >= 0)) return true;		// We were turning left motor in reverse direction
	    if ((turnDir > 0) && (Robot::drivetrain->GetLeftSpeed() <= 0)) return true;		// We were turning Left Motor in forward direction
	} else {
		// Right motors active
		if ((turnDir < 0) && (Robot::drivetrain->GetRightSpeed() <= 0)) return true;	// We were turning Right motor in forward direction
	    if ((turnDir > 0) && (Robot::drivetrain->GetRightSpeed() >= 0)) return true;	// We were turning Right Motor in reverse direction
	}
	return false;																		// we are not stopped
}




// --------------------------------------------------------------------------
//                      Heading Angle Routines
// --------------------------------------------------------------------------

float DriveSwingTurnCmd::AddAngleToHdg(double hdg, double angle){
	return  ConstrainDeg0To360( hdg + angle);
}

double DriveSwingTurnCmd::ConvertHdgToAngle(double hdg){
	double angle = hdg;
	if (hdg > 180)  angle -= 360;
	if (hdg < -180)	angle += 360;
	return  angle;
}
double DriveSwingTurnCmd::ConvertAngleToHdg(double angle){
	double tempHdg;
	if (angle >= 0){
		tempHdg = angle;
	}
	else {
		tempHdg = angle + 360;
	}
	return ConstrainDeg0To360(tempHdg);
}

double DriveSwingTurnCmd::CalcRemainAngle(double currHdg , double destHdg){
	// Return -180 to + 180 degrees between the 2 provided headings
	// difference < 0 means destination heading is to the Left CCW of current heading
	// difference > 0 means destination heading is to the Right CW of current heading
	double tempDiff = destHdg - currHdg;
	if (tempDiff > 180)  tempDiff -= 360;
	if (tempDiff < -180) tempDiff += 360;
	return tempDiff;
}

double DriveSwingTurnCmd::ConstrainDeg0To360(double deg){
	while (deg > 360) {
		deg -= 360;
	}
	while (deg < 0){
		deg += 360;
	}
	return deg;
}
double DriveSwingTurnCmd::ConstrainDeg0To180(double deg){
	return ConstrainDeg0To360(deg + 180) - 180;
}

float DriveSwingTurnCmd::Round(float value, int digits){
	int mult = 1;
	if (digits == 0) mult = 1;
	else if (digits == 1) mult = 10;
	else if (digits == 2) mult = 100;
	else if (digits == 3) mult = 1000;
	else if (digits == 4) mult = 10000;
	else if (digits == 5) mult = 100000;
	else if (digits == 6) mult = 1000000;
	return (round(value * mult) / mult);
}
