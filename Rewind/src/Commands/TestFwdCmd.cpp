// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "TestFwdCmd.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

TestFwdCmd::TestFwdCmd(): Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::drivetrain.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void TestFwdCmd::Initialize() {
	GetTestData();
	GetProfileData();
	SetTimeout(fwdTest.TO);

	line = "Debug, Drivetrain, Starting TestFwdCmd";
	line += " Speed=" + std::to_string(fwdTest.Vel) + " Dist=" + std::to_string(fwdTest.Dist);
	line += " TimeOut=" + std::to_string(fwdTest.TO) + " Mode=" + std::to_string(fwdTest.Mode);
	Robot::logger->appendLog(line);

	Robot::drivetrain->ResetEncoders();
	Robot::drivetrain->SetFirstTimeFlag(0);					// set flag to zero for gyro correction

	if (fwdTest.Dist < 0) fwdTest.Dist = fwdTest.Dist * -1;	// Distance is always positive, speed can be negative
	m_CurrTgtDist = m_RemainTgtDist = fwdTest.Dist;

	if 		(m_RemainTgtDist > ZoneArray[4].StartofZone) zoneNum = 4;
	else if (m_RemainTgtDist > ZoneArray[3].StartofZone) zoneNum = 3;
	else if (m_RemainTgtDist > ZoneArray[2].StartofZone) zoneNum = 2;
	else if (m_RemainTgtDist > ZoneArray[1].StartofZone) zoneNum = 1;
	else 												 zoneNum = 0;

	zonePwr = ZoneArray[zoneNum].AccelPwr;

	Robot::drivetrain->PutZoneData(zoneNum, ZoneArray[zoneNum].CruiseSpeed,  fwdTest.Dist, m_RemainTgtDist, zonePwr);
	Robot::drivetrain->TankDrive(zonePwr , zonePwr);
	//	Robot::drivetrain->Drive(zonePwr, 0);
}

// Called repeatedly when this Command is scheduled to run
void TestFwdCmd::Execute() {

	drivetrainCurrDist = Robot::drivetrain->GetAverageDist();;
	m_RemainTgtDist = fwdTest.Dist - drivetrainCurrDist;
	drivetrainCurrVel = Robot::drivetrain->GetAverageSpeed();


	if 		(m_RemainTgtDist > ZoneArray[4].EndofZone) zoneNum = 4;
	else if (m_RemainTgtDist > ZoneArray[3].EndofZone) zoneNum = 3;
	else if (m_RemainTgtDist > ZoneArray[2].EndofZone) zoneNum = 2;
	else if (m_RemainTgtDist > ZoneArray[1].EndofZone) zoneNum = 1;
	else if (m_RemainTgtDist > ZoneArray[0].EndofZone) zoneNum = 0;

	zonePwr = GetZonePwr( zoneNum );

	Robot::drivetrain->PutZoneData( zoneNum,  ZoneArray[zoneNum].CruiseSpeed, fwdTest.Dist, m_RemainTgtDist, zonePwr);

	Robot::drivetrain->TankDrive(zonePwr , zonePwr);
	//Robot::drivetrain->Drive(zoneSpeed, 0);
}

// Make this return true when this Command no longer needs to run execute()
bool TestFwdCmd::IsFinished() {
	if (IsTimedOut()) return true;	// used in all modes
	if (m_RemainTgtDist <= 0) return true; // were at the end get out

	return false;
}

// Called once after isFinished returns true
void TestFwdCmd::End() {
	Robot::drivetrain->StopMtrs();							// stop the motors
	Robot::logger->appendLog("Ending TestFwdCommand");
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void TestFwdCmd::Interrupted() {
	End();
}

// -------------------------------------------------------------
//                     User Defined Methods
// -------------------------------------------------------------
double TestFwdCmd::GetZonePwr(int zone){
	float drivePwr;
	if (drivetrainCurrVel < ZoneArray[zone].CruiseSpeed - 2 ) {	// we still havent reached full velocity continue to accel
			drivePwr = ZoneArray[zone].AccelPwr;
		}
		else if (drivetrainCurrVel > ZoneArray[zone].CruiseSpeed + 2 ) { // we are too fast need to decelerate
			drivePwr = ZoneArray[zone].DecelPwr;
		}
		else { // we are at full speed for this zone so just continue
			drivePwr =  ZoneArray[zone].CruisePwr;
		}
	return drivePwr;

}
// ------------------------ Get System Test Default Values --------------------
void TestFwdCmd::GetTestData(){
	netTable = NetworkTable::GetTable("Preferences");

	fwdTest.Vel = netTable->GetNumber("Vel",0);
	fwdTest.Dist = netTable->GetNumber("Dist",0);
	fwdTest.TO = netTable->GetNumber("TO",0);
	fwdTest.Mode = netTable->GetNumber("Mode",0);


}

// ------------------------ Get System Test Default Values --------------------
void TestFwdCmd::GetProfileData(){
	//netTable = NetworkTable::GetTable("Preference/Profiles");

	ZoneArray[0].CruiseSpeed = 6;
	ZoneArray[1].CruiseSpeed = 15;
	ZoneArray[2].CruiseSpeed = 30;
	ZoneArray[3].CruiseSpeed = 45;
	ZoneArray[4].CruiseSpeed = 80;

	ZoneArray[0].CruisePwr = 0.35;
	ZoneArray[1].CruisePwr = 0.45;
	ZoneArray[2].CruisePwr = 0.65;
	ZoneArray[3].CruisePwr = 0.8;
	ZoneArray[4].CruisePwr = 0.95;

	ZoneArray[0].StartofZone = 3.5;
	ZoneArray[1].StartofZone = 10;
	ZoneArray[2].StartofZone = 20;
	ZoneArray[3].StartofZone = 38;
	ZoneArray[4].StartofZone = 99999;

	ZoneArray[0].EndofZone = 0.25;
	ZoneArray[1].EndofZone = 3.0;
	ZoneArray[2].EndofZone = 8.0;
	ZoneArray[3].EndofZone = 18.0;
	ZoneArray[4].EndofZone = 36.0;

	ZoneArray[0].AccelPwr = 0.5;
	ZoneArray[1].AccelPwr = 0.6;
	ZoneArray[2].AccelPwr = 0.75;
	ZoneArray[3].AccelPwr = 1.0;
	ZoneArray[4].AccelPwr = 1.0;

	ZoneArray[0].DecelPwr = -0.25;
	ZoneArray[1].DecelPwr = -0.25;
	ZoneArray[2].DecelPwr = -0.25;
	ZoneArray[3].DecelPwr = -0.25;
	ZoneArray[4].DecelPwr = -0.25;
}

