// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "DriveByJoystickCmd.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

DriveByJoystickCmd::DriveByJoystickCmd(): Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::drivetrain.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void DriveByJoystickCmd::Initialize() {
	Robot::logger->appendLog("Starting DriveByJoystickCmd");
	stopFlag = 0;			// clear the braking flag
	stopTmr.Reset();
}

// Called repeatedly when this Command is scheduled to run
void DriveByJoystickCmd::Execute() {
	// check to see if trigger is pushed
	if (Robot::oi->getDriverJoystick()->GetRawButton(1) == true) {  // Joystick is activated !
		if (Robot::drivetrain->GetProbeLmtSw() == false) { 		// The probe limit switch has been tripped we may need to stop
			if (Robot::oi->getDriverJoystick()->GetY() < 0) { 	// Joystick is trying to drive forward
				ProcessBrake();									// we need to brake of keep motors from moving forward
			}
			else {												// Joystick is trying to backout stop any braking and allow driver to back out
				stopTmr.Stop();
				stopTmr.Reset();
				stopFlag = 0;
				Robot::drivetrain->DriveByJoystick(Robot::oi->getDriverJoystick());
			}
		}
		else {													 // Probe switch has  not been tripped
			stopTmr.Stop();
			stopTmr.Reset();
			stopFlag = 0;
			Robot::drivetrain->DriveByJoystick(Robot::oi->getDriverJoystick());
		}
	}
	else {														// Joystick button not pressed
		Robot::drivetrain->StopMtrs(); }
}


// Make this return true when this Command no longer needs to run execute()
bool DriveByJoystickCmd::IsFinished() {
    return false;
}

// Called once after isFinished returns true
void DriveByJoystickCmd::End() {
	Robot::drivetrain->StopMtrs();
	Robot::logger->appendLog("Ending DriveByJoystickCmd");
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void DriveByJoystickCmd::Interrupted() {
	End();
}


void DriveByJoystickCmd::ProcessBrake(){
	if (stopFlag == 0){			// we have just tripped the probe switch for the first time, need to start braking
			stopFlag = 1;
			stopTmr.Start();
		}

	if (stopFlag == 1){										// we are in the process of braking
		if (Robot::drivetrain->GetAverageSpeed() > 0){		// we are still moving forward continue braking
			Robot::drivetrain->TankDrive(-0.3, -0.2);
		}
		else {												// we have finally stopped
			Robot::drivetrain->StopMtrs();
			stopFlag = 2;									// we are stopped
		}
	}
}

