// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "VisionUpdate2Cmd.h"
#include "Math.h"
#include "WPILib.h"
//#include "../Point.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

VisionUpdate2Cmd::VisionUpdate2Cmd(): Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::vision.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void VisionUpdate2Cmd::Initialize() {
	netTable = NetworkTable::GetTable("MyVisionData");
	lastCOGX = lastCOGY = 999;		//	Set last value to one that can't be achieved to start irst time
	line = "Debug, Vision, Starting VisionUpdateCmd";
	Robot::logger->appendLog(line);
	std::cout << "Starting vision update Cmd" << std::endl;
	B = C = D = E = G = H = 0;
}

// Called repeatedly when this Command is scheduled to run
void VisionUpdate2Cmd::Execute() {
	GetVisionData();
	if ((COGX == lastCOGX) && (COGY == lastCOGY)) return;		// return if data hasn't changed
	lastCOGX = COGX;											// reset lastCOG positions
	lastCOGY = COGY;
	if ((COGX == 0) && (COGY == 0)) {							// No valid tgt in view
		Robot::vision->SetCOG(0,0);
		Robot::vision->SetTgtFlag( 0 );
		Robot::logger->appendLog("Debug, Vision : No Valid vision target in site");
		return;
	}
	Robot::vision->SetCOG(COGX,COGY);
	CalcTgtHdgDist();										// The Vision X,Y position calculations
	CalcRobotPosition();									// This data will be used to plot a route
	route.clearAllSeg();
	retCode = CalcSingleCurveSoloution();					// Attempt to calculate a single turn solution
	if (retCode > 0)
		return;												// We had a valid single solution, were done
	retCode = CalcDblCurveSolution();						// Calculate a dbl turn solution to target
}


// Make this return true when this Command no longer needs to run execute()
bool VisionUpdate2Cmd::IsFinished() {
    return true;
}

// Called once after isFinished returns true
void VisionUpdate2Cmd::End() {
	std::cout << "End vision update Cmd" << std::endl;
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void VisionUpdate2Cmd::Interrupted() {

}

// ****************************************************************
//                  MAIN Code Body
// ****************************************************************

void VisionUpdate2Cmd::CalcTgtHdgDist(){
	// ---------------------------------------------------------
	// Step 1 Determine Robot Alignment Error with Target Wall
	// ---------------------------------------------------------
	// Robot rotated RIGHT of center = + Positive rotated LEFT of center = - Negative
	// negative hdAngleOffset = tgt will look more to the right, Positive = more to the left in image
	currYaw = Robot::drivetrain->GetGyroYaw();
	currHdg = Robot::drivetrain->GetGyroHeading();
	tgtAlignError = 0;
	if ((currYaw < 30) && (currYaw > -30)){						// where in center position ( <0 =
		tgtAlignError = (currYaw + 0);
	}
	if ((currYaw < -30) && (currYaw > -90)){					// were in right position
		tgtAlignError = (currYaw + 60);
	}
	if ((currYaw < 90) && (currYaw > 30)){						// were in left position
		tgtAlignError = (currYaw - 60);
	}
	Robot::vision->SetCurrYaw(currYaw);
	Robot::vision->SetAngleCorrection(tgtAlignError);

	// --------------------------------------------------------------
	// Step 2  Determine Robots Distance to Target Wall
	// --------------------------------------------------------------
	//htAngle =  COGY * DEGPERPIXLE;
	htAngle = (0.1730 * COGY) - 0.36;									// This was arrived at experimentally
	distToWall = TgtHt / mTan(htAngle);
	Robot::vision->SetWallDist( distToWall );

	// --------------------------------------------------------------
	// Step 3 Determine Target Offset from Robot Center
	// --------------------------------------------------------------
	angleX = ConvertImagePosToAngle(COGX , 98);
	angleF = angleX + tgtAlignError;
	tgtShiftDist = distToWall * (mTan(angleF));
	Robot::vision->SetTgtAngles(angleX, angleF);
	Robot::vision->SetTgtTransCorrection(tgtShiftDist, tgtShiftDist);

	// --------------------------------------------------------------
	//  Step 4 Determine Target Heading
	// --------------------------------------------------------------
	sidee = distToWall - tgtDistFromWall;								// dist to tip from wall- decreased for greater accuracy
	if (sidee == 0) sidee = 0.00000001;									// prevent divide by zero later, this should'nt occur
	tipDist = sqrt((sidee * sidee) + (tgtShiftDist * tgtShiftDist));	// hypot = sqrt((run^2) + (rise^2))
	angleToTip = mAtan(tgtShiftDist,sidee);								// tip angle = atan(rise/run)
	if ((currYaw < 30) && (currYaw > -30)){								// where in center position ( <0 =
		tipHdg = angleToTip;
	}
	else if ((currYaw < -30) && (currYaw > -90)){						// were in right position
		tipHdg = angleToTip - 60;
	}
	else if ((currYaw < 90) && (currYaw > 30)){							// were in left position
		tipHdg = angleToTip + 60;
	}
	else {
		tipHdg = 0;														// something is wrong go straight
	}
	tipHdg = convAngleToHdg(tipHdg);									// Make sure Hdg is 0-360
	Robot::vision->SetTipHdgDist(tipHdg, tipDist);						// Send tipHdg, tipDist to vision subsystem
	Robot::vision->SetTgtFlag(1);
	PutVisionData();
	LogVisionData();
}

void VisionUpdate2Cmd::CalcRobotPosition(){
	// Calculate Robot X,Y Position, angle relative to target and end point X,Y
	B = robotFrontToCtr * (mCos(tgtAlignError));
	C = robotFrontToCtr * (mSin(tgtAlignError));
	D = distToWall *  (mTan(angleF));
	E = distToWall;
	G = D + C;
	H = distToWall + B;
	rbt.COG = Point (COGX, COGY);
	rbt.hdg = currHdg;
	rbt.yaw = currYaw;
	rbt.pos = Point(G,H);
	rbt.startPt = rbt.pos;
	rbt.endPt = Point((tgtDistFromWall + robotFrontToCtr + 5), 0);	// tgtDistFromWall is short so added 5 inches
	// The angle needs to be modified to reverse direction for the curve calculations. This code was originally
	// intended for a backing up to target solution. Not a forward driving robot. This needs to be re-written
	// later for forward direction.
	rbt.angle = convAngleToHdg(360 - tgtAlignError);		// This is to reverse angle for the curve calculations
}

int VisionUpdate2Cmd::CalcSingleCurveSoloution(){
    double radius = 0, sideDist = 0;
    Point pt1,pt2,ctrPt;
    int quad = mGetQuad(rbt.angle);
	if 		((quad == 1) && (rbt.pos.y < 0)) 	return(-2);		// No single turn solution
	else if ((quad == 2) && (rbt.pos.y < 0))    return(-4);		// No single turn solution
    else if ((quad == 3) && (rbt.pos.y > 0))   	return(-5);		// No single turn solution
    else if ((quad == 4) && (rbt.pos.y > 0))   	return(-7);		// No single turn solution

	// Looks like we might have single turn solution ... We just have to check distances
    rbt.xAxisIntPt.x = (rbt.pos.x - (rbt.pos.y * (mSin(90-rbt.angle)) / mSin(rbt.angle)));
    rbt.xAxisIntPt.y = 0;
    if (rbt.xAxisIntPt.x < rbt.endPt.x)			return(-9);		// No single turn solution

    rbt.disty = rbt.endPt.dist(rbt.xAxisIntPt);
    rbt.distx = rbt.startPt.dist(rbt.xAxisIntPt);
    if (rbt.distx < rbt.disty)
    	radius = calcRadiusOfTurn(rbt.distx, rbt.angle);
    else
        radius = calcRadiusOfTurn(rbt.disty, rbt.angle);

    if (radius < tmtr)				        return(-11);   		// No single turn solution (radius is too tight)    }
    sideDist = mRound(radius * mTan(0.5 * rbt.angle),3);
    if (rbt.distx < rbt.disty){
        // Robot is closer to the Xaxis than the Yaxis so arc STARTS at car and ends on the Xaxis
    	// A straight section is needed after the arc to get to the endpoint (PT2 to endPT)
        pt1 = rbt.startPt;
        pt2 = Point(rbt.xAxisIntPt.x - abs(sideDist), 0);
    }
    else{
        // Robot is closer to the Yaxis than the Xaxis so arc ENDS at endpoint and a
    	// A straight section is needed at the beginning (startPt to PT1)
        pt1 = Point(rbt.xAxisIntPt.x + (abs(sideDist) * mCos(rbt.angle)), abs(sideDist) * mSin(rbt.angle));
        pt2 = rbt.startPt;
    }
    ctrPt = Point(pt2.x, copysign(radius,sideDist));

    // ---------- We Have a good solution for a single turn Build Arc Segment ---------
    int dir, len;
    if (ctrPt.y >= 0)
    	// On a single curve solution, Arc curve will be
    	// Clockwise (pt1 to pt2) above xAxis
    	dir = +1;								// +1 = Clockwise (pt1 to pt2)
    else
    	// On a single curve solution, Arc curve will be
	    // Counter Clockwise (pt1 to pt2) below xAxis
        dir = -1;								// +1 = Counter Clockwise (pt1 to pt2)
    len = CalcArcLen(rbt.angle, ctrPt, pt1, pt2, dir);
    rbt.snglArc.arc(pt1, pt2, ctrPt, radius, dir, len);

    // ---- build route list of segments  ---------
    Segment strSeg;
    if (pt1 == rbt.startPt) {
        rbt.rbtRoute.append(rbt.snglArc);          	// Add Arc turn to route list
        strSeg.strt(pt2, rbt.endPt);
        rbt.rbtRoute.append(strSeg);				// Add a straight segment to get to endPt
    }
    else {
    	strSeg.strt(rbt.startPt, pt1);
    	rbt.rbtRoute.append(strSeg);				// Add a straight segment to get to Arc Pt1
    	rbt.rbtRoute.append(rbt.snglArc);			// Add Arc turn to route list
    }
    PostRoute();									// Send the route table to the vision subsystem
    return(1);										// return value > 0 means successful solution
}

int VisionUpdate2Cmd::CalcDblCurveSolution(){
	double radius;
	retCode = angleQuad();
    rbt.xAxisIntPt = Point(rbt.startPt.x-(rbt.startPt.y * mSin(90-rbt.angle) / mSin(rbt.angle)), 0);
    rbt.disty = rbt.endPt.dist(rbt.xAxisIntPt);
    rbt.distx = rbt.startPt.dist(rbt.xAxisIntPt);
    radius = CalcDblCircle();
    if (radius < tmtr) // No good solution
        return (0);

    Segment arc1, arc2;				// create 2 segments
    arc1.startPt = rbt.startPt;
    arc1.endPt = Point((rbt.ctrPt2.x + rbt.ctrPt1.x)/2,(rbt.ctrPt2.y + rbt.ctrPt1.y)/2);
    arc1.ctrPt = rbt.ctrPt1;
    arc1.radius = rbt.radius;
    arc1.dir = rbt.arcDir1;
    arc2.startPt = arc1.endPt;
    arc2.endPt = rbt.endPt;
    arc2.radius = rbt.radius;
    arc2.dir = rbt.arcDir2;
    arc2.ctrPt = rbt.ctrPt2;

    // --- Calculate arc segment length
    arc1.len = CalcArcLen(rbt.angle, arc1.ctrPt, arc1.startPt, arc1.endPt, arc1.dir);
    arc2.len = CalcArcLen(rbt.angle, arc2.ctrPt, arc2.startPt, arc2.endPt, arc2.dir);

    rbt.rbtRoute.clearAllSeg();
    rbt.rbtRoute.append(arc1);               // Add Arc turn to route list
    rbt.rbtRoute.append(arc2);               // Add Arc turn to route list

    PostRoute();							// Send the route table to the vision subsystem
	return (1);
}



// *************************** Calculate Turn Radius Routine ********************************
double VisionUpdate2Cmd::calcRadiusOfTurn(double dist, double angle){
	// Calculate turning radius based on available side distance and current car angle'''
    double turnradius = (dist/ mTan(angle)/2);
    return (abs(turnradius));
}

void VisionUpdate2Cmd::PostRoute(){
	Robot::vision->SetRoute(rbt.rbtRoute);
}


// ------------------------ Get System Test Default Values --------------------
void VisionUpdate2Cmd::GetVisionData(){
//	netTable = NetworkTable::GetTable("MyVisionData");
//	COGX = netTable->GetNumber("COG_X",0);
//	COGY = netTable->GetNumber("COG_Y",0);
	COGX = Robot::vision->GetUDPCOGX();
	COGY = Robot::vision->GetUDPCOGY();

}

// *********************************************************************************
//                             Various Conversion Routines
// *********************************************************************************

// --------------------------------------------------------------------------
//                             Image Angle/Pixle Conversions
// --------------------------------------------------------------------------
float VisionUpdate2Cmd::ConvertImageAngleToPixelCnt(float angle, float ctr){
	float pos=0;
	pos = (angle / DEGPERPIXLE) + ctr;
	return (mRound(pos, 0));
}

float VisionUpdate2Cmd::ConvertImagePosToAngle(float pos, float ctr ){
	// returns < 0 = left of Ctr,  > 0 = right of Ctr
	float angle;
	//angle = ( pos - ctr ) * DEGPERPIXLE;
	angle = (0.1730 * (pos - ctr)) - 0.36;
	return (angle);
}

// *************************** angle Quadrant Function ****************************
int VisionUpdate2Cmd::angleQuad(){
	//int VisionUpdate2Cmd::angleQuad(rbt.angle, rbt.startPt, rbt.distx, rbt.disty){
	// ARC1Dir goes with arc2 and arc2Dir goes with arc1
    // this really should be cleaned up but it workds ....
    int testFlag = 0;
	int quad = mGetQuad(rbt.angle);

    if (rbt.startPt.y <= 0) {
        if		(quad == 1)		testFlag = 1;
        else if (quad == 2)		testFlag = 2;
    }
    else {
    	if 		(quad == 3)		testFlag = 3;
    	else if (quad == 4)		testFlag = 4;
    }
    if (rbt.startPt.y <= 0){
    	if   ((quad == 3) && (distx < disty))		testFlag = 5;
    	else if ((quad == 3) && (distx >= disty))   testFlag = 6;
    	else if ((quad == 4) && (distx >= disty))   testFlag = 6;
    	else if ((quad == 4) && (distx < disty))	testFlag = 7;
    }
    else {
        if   	((quad == 1) && (distx < disty))	testFlag = 8;
        else if ((quad == 2) && (distx < disty))	testFlag = 8;
        else if ((quad == 1) && (distx >= disty))   testFlag = 9;
        else if ((quad == 2) && (distx >= disty))   testFlag = 9;
    }
	// The ctr1Sign indicates if the first Arc segment center is above the Xaxis. ( + = above Xaxis - = below Xaxis)
	// On a Dble curve solution, if the first Arc ctr1sign > 0 (Above the Xaxis) the Arc curve will be Clockwise.
	// The second Arc curve will always be opposite the first arc curve. arcXDir ( + = Clockwise, - = Counter Clockwise)

	rbt.arcDir1   = signArray[testFlag][1];
    rbt.arcDir2   = (signArray[testFlag][1]) * -1;
    rbt.ctr1sign  = signArray[testFlag][1];
    rbt.ctr2xsign = signArray[testFlag][2];
    rbt.ctr2ysign = signArray[testFlag][3];
	return(testFlag);
}


// ********** Calculate angle/length between two arcs points Function **************
double VisionUpdate2Cmd::CalcArcLen(double angle, Point ctrPt, Point startPt, Point endPt, double dir){
	// startAhgle = robot hdg 0-360
	// dir > 0 means Arc is Clockwise from pt1 to pt2, and CtrPt.y > 0
	Point tAngle1, tAngle2;
    if (dir > 0){
    	// To calculate accurate angle need to swap pt1 and pt2 in this case
        tAngle1 = ctrPt.cartToPolar(startPt);	// returns hdg angle between 0-360
        tAngle2 = ctrPt.cartToPolar(endPt);		// returns hdg angle between 0-360
    }
    else {
        tAngle1 = ctrPt.cartToPolar(endPt);		// returns hdg angle between 0-360
        tAngle2 = ctrPt.cartToPolar(startPt);	// returns hdg angle between 0-360
    }
    double tArcAngle = fmod((360 - (tAngle2.y - tAngle1.y)),360);
    double tEndAngle = calcHdgSum(angle, -tArcAngle);
    //double tEndAngle = angle - tArcAngle;
    double tArcLen = ((2 * pi * rbt.radius)/360) * tArcAngle;
    return (tArcLen);
}

// *************************** Calculate Dbl Circle Ctr Points and Radius ********************************
double VisionUpdate2Cmd::CalcDblCircle(){
	double a,b,c,r, tAngle, carx, cary;
	angleQuad();					// calculate all the signs for the quad calculation
    carx = rbt.pos.x - rbt.endPt.x;
    cary = rbt.pos.y - rbt.endPt.y;
    tAngle = abs(rbt.angle - 270);
    a = (2 - rbt.ctr1sign *2 * rbt.ctr2ysign * sin(tAngle));
    b = (2 * (carx * rbt.ctr2xsign * cos(tAngle)) + rbt.ctr1sign * 2 * cary + rbt.ctr2ysign * (2 * (cary * sin(tAngle))));
    c = -1 *(carx *carx  + cary *cary );
    r = mQuad( a, b, c);
    rbt.ctrPt1 = Point(0, rbt.ctr1sign * r);
    rbt.ctrPt2 = Point(carx - r * rbt.ctr2xsign * cos(tAngle), cary - r * rbt.ctr2ysign * sin(tAngle));
    rbt.radius = r;
    rbt.ctrPt1 = Point(rbt.ctrPt1.x + rbt.endPt.x, rbt.ctrPt1.y + rbt.endPt.y);
    rbt.ctrPt2 = Point(rbt.ctrPt2.x + rbt.endPt.x, rbt.ctrPt2.y + rbt.endPt.y);
    return (r);
}


// ------------------------ Get System Test Default Values --------------------
void VisionUpdate2Cmd::PutVisionData(){
	netTable->PutNumber("COGX",COGX);
	netTable->PutNumber("COGY",COGY);
	netTable->PutNumber("currHdg",currHdg);
	netTable->PutNumber("currYaw",currYaw);
	netTable->PutNumber("AlignErr",tgtAlignError);

	netTable->PutNumber("htAngle",htAngle);
	netTable->PutNumber("DistToWall",distToWall);
	netTable->PutNumber("angleX",angleX);
	netTable->PutNumber("angleF",angleF);
	netTable->PutNumber("tgtShiftDist",tgtShiftDist);

	netTable->PutNumber("tgtDistFromWall",tgtDistFromWall);
	netTable->PutNumber("sidee",sidee);

	netTable->PutNumber("angleToTip",angleToTip);
	netTable->PutNumber("sidee",sidee);
	netTable->PutNumber("sidee",sidee);
	netTable->PutNumber("sidee",sidee);

	netTable->PutNumber("tgtDist",tgtDist);
	netTable->PutNumber("tipDist",tipDist);

	netTable->PutNumber("Pos B",B);
	netTable->PutNumber("Pos C",C);
	netTable->PutNumber("Pos D",D);
	netTable->PutNumber("Pos E",E);
	netTable->PutNumber("Pos G",G);
	netTable->PutNumber("Pos H",H);
	netTable->PutNumber("Pos ctrX",rbt.pos.x);
	netTable->PutNumber("Pos ctrY",rbt.pos.y);
	netTable->PutNumber("Pos endX",rbt.endPt.x);
	netTable->PutNumber("Pos endY",rbt.endPt.y);
	netTable->PutNumber("Pos Angle",rbt.angle);
}


void VisionUpdate2Cmd::LogVisionData(){
	line = "Debug, Vision Step 1 ";
	line += ",COGXY =" +  std::to_string(COGX) + "," +std::to_string(COGY) ;
	line += ",currHdg =" +  std::to_string(currHdg);
	line += ",currYaw =" +  std::to_string(currYaw);
	line += ",AlignErr =" +  std::to_string(tgtAlignError);
	Robot::logger->appendLog(line);

	line = "Debug, Vision Step 2 ";
	line += ",htAngle =" +  std::to_string(htAngle);
	line += ",tgtDistToWall =" +  std::to_string(distToWall);
	Robot::logger->appendLog(line);

	line = "Debug, Vision Step 3 ";
	line += ",angleX =" +  std::to_string(angleX);
	line += ",angleF =" +  std::to_string(angleF);
	line += ",tgtShiftDist =" +  std::to_string(tgtShiftDist);
	Robot::logger->appendLog(line);

	line = "Debug, Vision Step 4 ";
	line += " ,tgtDistFromWall=" +  std::to_string(tgtDistFromWall);
	line += " ,sidee=" +  std::to_string(sidee);
	line += ",angleToTip =" +  std::to_string(angleToTip);
	line += " ,tipDist=" +  std::to_string(tipDist);
	line += " ,tipHdg=" +  std::to_string(tipHdg);
	Robot::logger->appendLog(line);

	line = "Debug, Vision Robot Position 5 ";
	line += " ,Pos B=" +  std::to_string(B);
	line += " ,Pos C=" +  std::to_string(C);
	line += " ,Pos D=" +  std::to_string(D);
	line += " ,Pos E=" +  std::to_string(E);
	line += " ,Pos G=" +  std::to_string(G);
	line += " ,Pos H=" +  std::to_string(H);
	line += " ,Pos ctrX=" +  std::to_string(rbt.pos.x);
	line += " ,Pos ctrY=" +  std::to_string(rbt.pos.y);
	line += " ,Pos endX=" +  std::to_string(rbt.endPt.x);
	line += " ,Pos endY=" +  std::to_string(rbt.angle);
	line += " ,Pos Angle=" +  std::to_string(rbt.angle);
	Robot::logger->appendLog(line);
}

/*

    def CalcRadius(self):
        if (self.lastpos.x ==0 and self.lastpos.y == 0):
            self.lastpos = self.car.pos
            self.turnradius = 0
            self.turnctr=Point(0,0)
            return
        if (self.lastpos.x == self.car.pos.x and self.lastpos.y == self.car.pos.y ):
            return
        x2 = self.lastpos.x
        y2 = self.lastpos.y
        x1 = self.car.pos.x
        y1 = self.car.pos.y
        angle = self.car.angle
        m1 = tan(angle - 90)
        mm  = -1* (x1-x2)/(y1 - y2)
        if (m1 == mm):
            m1 = m1 + 0.0000000001       # make sure we dont divide by zero
        xm = (x1 + x2)/2
        ym = (y1 + y2)/2
        x = (y1 - ym - m1 * x1 + mm * xm) /   (mm - m1)
        y = mm * (x -xm) + ym
        r = math.sqrt((x1 - x)**2 + (y1 - y)**2)
        self.lastpos = self.car.pos
        self.turnradius = r
        self.turnctr=Point(x,y)
}
*/

