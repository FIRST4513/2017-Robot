// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "TestPIDCmd.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

TestPIDCmd::TestPIDCmd(): Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::drivetrain.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void TestPIDCmd::Initialize() {
	GetTestData();
	SetTimeout(m_PIDtestTO);

	line = "Debug, Drivetrain, Starting TestPID Cmd";
	line += " PIDp=" + std::to_string(m_PIDp);
	line += " PIDi=" + std::to_string(m_PIDi);
	line += " PIDd=" + std::to_string(m_PIDd);
	line += " PIDf=" + std::to_string(m_PIDf);
	line += " PIDtestVel=" + std::to_string(m_PIDtestVel);
	line += " PIDtestDist=" + std::to_string(m_PIDtestDist);
	line += " PIDtestTO=" + std::to_string(m_PIDtestTO);
	Robot::logger->appendLog(line);

	Robot::drivetrain->ResetEncoders();
	Robot::drivetrain->SetFirstTimeFlag(0);

	m_RemainDist = m_PIDtestDist;

	// ---------- Set PID Constants & Limits ----------------------
	Robot::drivetrain->PIDSetConst(m_PIDp, m_PIDi, m_PIDd, m_PIDf);
	Robot::drivetrain->PIDSetLimits(m_PIDmax, m_PIDmin, m_PIDizone, m_PIDramp);
	Robot::drivetrain->PIDreset(0);		// reset left motor
	Robot::drivetrain->PIDreset(1);		// reset right motor
	motionStartedFlag = 0;

	// ----------- Calculate Motor Pwr by PID routine -----------
	// m_LeftMotorPwr = Robot::drivetrain->PIDCalcValue( 0, m_PIDtestVel, 0);
	// m_RightMotorPwr = Robot::drivetrain->PIDCalcValue( 0, m_PIDtestVel, 1);

	m_currPwr = Robot::drivetrain->PIDCalcValue( (double) 0, m_PIDtestVel, 0); 	// Calculate pwr for motors
	std::cout << "PID Test Init" << std::endl;
	std::cout << "PID Calc returned " << std::to_string(m_currPwr) << std::endl;
	Robot::drivetrain->TankDrive(m_currPwr, m_currPwr);		// well start just with just average speed

	// ------ put out logging data -----------
	Robot::drivetrain->PutZoneData(6, m_PIDtestVel,  m_PIDtestDist, m_RemainDist, m_currPwr);	// Post values for logger
}

// Called repeatedly when this Command is scheduled to run
void TestPIDCmd::Execute() {
	// -- Calculate current speed and distance
	m_drivetrainCurrDist = Robot::drivetrain->GetAverageDist();
	m_drivetrainCurrSpeed = Robot::drivetrain->GetAverageSpeed();
	m_RemainDist = m_PIDtestDist - m_drivetrainCurrDist;

	if (m_drivetrainCurrSpeed > 0.5 ) motionStartedFlag =1;

	// ---- calculate new power settings based on Distance --------
	if (m_RemainDist <= 0){ // we have gone as far ar requested, time to brake to a stop
		m_currPwr = -0.30; }
	else { // calculate using PID new pwr setting
		m_currPwr = Robot::drivetrain->PIDCalcValue( m_drivetrainCurrSpeed, m_PIDtestVel, 0); 	// Calculate pwr for motors
	}

	//std::cout << "PID Calc returned " << std::to_string(m_currPwr);
	//std::cout << " Speed=" + std::to_string(m_drivetrainCurrSpeed);
	//std::cout << " DistRemain=" + std::to_string(m_RemainDist) << std::endl;

	Robot::drivetrain->TankDrive(m_currPwr, m_currPwr);	// well start just with just average speed
	Robot::drivetrain->PutZoneData((int)6, m_PIDtestVel, m_PIDtestDist, m_RemainDist, m_currPwr);	// Post values for logger
}

// Make this return true when this Command no longer needs to run execute()
bool TestPIDCmd::IsFinished() {
	if (IsTimedOut()) return true;	// used in all modes

	if ((m_drivetrainCurrSpeed <= 0.5) && (motionStartedFlag != 0)){
		// we have finally stopped or close to stop
		return true;
	}
    return false;
}


// Called once after isFinished returns true
void TestPIDCmd::End() {
	Robot::drivetrain->StopMtrs();							// stop the motors
	Robot::logger->appendLog("Ending TestPID Command");
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void TestPIDCmd::Interrupted() {
	End();
}


// ------------------------ Get System Test Default Values --------------------
void TestPIDCmd::GetTestData(){
	netTable = NetworkTable::GetTable("Preferences");

	m_PIDp = netTable->GetNumber("PIDp",0);
	m_PIDi = netTable->GetNumber("PIDi",0);
	m_PIDd = netTable->GetNumber("PIDd",0);
	m_PIDf = netTable->GetNumber("PIDf",0);

	m_PIDmax = netTable->GetNumber("PIDmax",0);
	m_PIDmin = netTable->GetNumber("PIDmin",0);
	m_PIDizone = netTable->GetNumber("PIDizone",0);
	m_PIDramp = netTable->GetNumber("PIDramp",0);

	m_PIDtestVel = netTable->GetNumber("PIDtestVel",0);
	m_PIDtestDist = netTable->GetNumber("PIDtestDist",0);
	m_PIDtestTO = netTable->GetNumber("PIDtestTO",0);
}

