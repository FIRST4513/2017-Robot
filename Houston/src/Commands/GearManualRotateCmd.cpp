// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "GearManualRotateCmd.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

GearManualRotateCmd::GearManualRotateCmd(): Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::gearHandler.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void GearManualRotateCmd::Initialize() {
	Robot::logger->appendLog("Debug, GearHandler, Starting ManualRotateCmd");
	//std::cout << "ManualRotateCmd Init" << std::endl;
	firstTimeFlag = 0;
	SetTimeout(5);		// timeout after 10 seconds
	rotFlag = 0;
	rotTimer.Reset();
}

// Called repeatedly when this Command is scheduled to run
void GearManualRotateCmd::Execute() {

	// if (Robot::gearHandler->GetGearInHopperSnsr() == Robot::gearHandler->GEARINHOPPER) {
	// we have a gear in the hopper    ... the sensor isn't working at this time

	if (firstTimeFlag == 0){
		//std::cout << "first time " << std::endl;

		// this is the first time into program check if we are on a gear already
		if (Robot::gearHandler->GetGearAlignedSnsr() == Robot::gearHandler->GEARALIGNED){
			// The gear IS already aligned so set flag to rotate until clear
			rotFlag = 1;		// this means we start gear rotating looking for it to clear
			firstTimeFlag = 1;
			Robot::gearHandler->RotateMtrOn();	// Start motor
		}
		else {
			rotFlag = 2;		//
			firstTimeFlag = 1;
		}
	}

	if (rotFlag == 1 ){
		//std::cout << "rot 1 " << std::endl;

		// look for gear spoke to clear sensor
		if (Robot::gearHandler->GetGearAlignedSnsr() == Robot::gearHandler->GEARALIGNED){
			// The gear IS still aligned so keep going until clear
			Robot::gearHandler->RotateMtrOn(); }	// Start motor
		else{
			// we have now cleared the gear spoke time to move on to next spoke
			rotFlag = 2;
			Robot::gearHandler->RotateMtrOn();	// Start motor
		}
	}

	if (rotFlag == 2 ){
		//std::cout << "rot 2 " << std::endl;

		// look for gear spoke to align again so we can time a stop
		if (Robot::gearHandler->GetGearAlignedSnsr() == Robot::gearHandler->GEARALIGNED){
			// The gear has just come back into alignment
			rotFlag = 3;
			rotTimer.Start(); }					// start the timer
		Robot::gearHandler->RotateMtrOn();  	// continue rotating to center the spoke
	}


	if (rotFlag == 3 ){
		//std::cout << "rot 3 " << std::endl;

		// We are just waiting for the timer to time out to stop the motor
		if (rotTimer.Get() > timeDelay) {
			// The gear rotation has timed out so stop the motor
			rotFlag = 4;	// were done so exit!
			rotTimer.Stop();
			Robot::gearHandler->RotateMtrOff();
		}
	}



}

// Make this return true when this Command no longer needs to run execute()
bool GearManualRotateCmd::IsFinished() {
	if (IsTimedOut()) return true;	// used in all modes
	if (rotFlag == 4) return true;

    return false;
}

// Called once after isFinished returns true
void GearManualRotateCmd::End() {
	Robot::gearHandler->RotateMtrOff();	// Stop motor
	Robot::logger->appendLog("Debug, GearHandler, Ending ManualRotateCmd");
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void GearManualRotateCmd::Interrupted() {
	End();
}
