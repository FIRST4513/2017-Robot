// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "VisionUpdate.h"
#include "Math.h"
#include "WPILib.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

VisionUpdate::VisionUpdate(): Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::vision.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void VisionUpdate::Initialize() {
	netTable = NetworkTable::GetTable("MyVisionData");
	lastCOGX = lastCOGY = 999;		//	Set last value to one that can't be achieved to start irst time
	line = "Debug, Vision, Starting VisionUpdateCmd";
	Robot::logger->appendLog(line);
	std::cout << "Starting vision update Cmd" << std::endl;
}

// Called repeatedly when this Command is scheduled to run
void VisionUpdate::Execute() {
	shiftTotDist = shiftHdg1 = shiftHdg2 = shiftFwdDist = 0;
	GetVisionData();

	if ((COGX == lastCOGX) && (COGY == lastCOGY)) return;		// return if data hasn't changed
	lastCOGX = COGX;											// reset lastCOG positions
	lastCOGY = COGY;
	if ((COGX == 0) && (COGY == 0)) {							// No valid tgt in view
		Robot::vision->SetCOG(0,0);
		Robot::vision->SetTgtFlag( 0 );
		return;
	}

	// ---- Determine angle to ctr of tgt -----
	angleX =  ConvertImagePosToAngle(COGX , 98);				// 105 (Ctr pos. comp. for miss-aligned camera)
	htAngle =  COGY * DEGPERPIXLE;
	double distToWall = TgtHt / (tan(CnvrtDegToRad(htAngle)));
	tgtDist = distToWall / (cos(CnvrtDegToRad(angleX)));

	// ----- Calculate alignment error with wall ----
	// negative hdAngleOffset = tgt will look more to the right, Positive = more to the left in image
	currYaw = Robot::drivetrain->GetGyroYaw();
	currHdg = Robot::drivetrain->GetGyroHeading();

	tgtAlignError = 0;
	if ((currYaw < 30) && (currYaw > -30)){						// where in center position ( <0 =
		tgtAlignError = (currYaw + 0);
	}
	if ((currYaw < -30) && (currYaw > -90)){					// were in right position
		tgtAlignError = (currYaw + 60);
	}
	if ((currYaw < 90) && (currYaw > 30)){						// were in left position
		tgtAlignError = (currYaw - 60);
	}

	// ------------------------------
	CalcProbTipHdg(currHdg, tgtAlignError, tgtDist, angleX);	// tipHdg and tipDist is set in this function
	Robot::vision->SetTipHdgDist( tipHdg, tipDist);				// pass the tip hdg and dist to vision subsystem

	// ------- This was used to calculate translation NOT USING AT THIS TIME ------------------
	adjAngleX = angleX + tgtAlignError;							// Angle to Tgt Ctr adjusted for miss-alignment with wall
	width = tgtDist * (tan(CnvrtDegToRad(adjAngleX)));			// width at Wall based on vision
	adjWidth = (tgtDist - sin(CnvrtDegToRad(adjAngleX)));		// adjWidth equal translation distance need at probe tip
	// ------- Update various fields in Vision subsystem for logging -----------------
	Robot::vision->SetTgtFlag(1);
	Robot::vision->SetTgtDist(tgtDist);
	Robot::vision->SetTgtTransCorrection(adjWidth, width);
	Robot::vision->SetCOG(COGX,COGY);
	Robot::vision->SetTgtAngles(angleX, htAngle);
	Robot::vision->SetCurrYaw(currYaw);
	Robot::vision->SetAngleCorrection(tgtAlignError);

	// ------- Calculate "S" curve Shift Data points ----------------------------------

	//CalcMaxShiftData(tipHdg, tipDist);
	CalcShiftData(tipHdg, tipDist);
	//if (shiftAngle >= 0) {
	//	if ((shiftAngle > maxShiftAngle) || (shiftDist > maxShiftDist)){
	//		shiftAngle = maxShiftAngle;	// Update for Negative values !!!!!!!!!
	//		shiftDist = maxShiftDist;}
	//} else {
	//	if ((abs(shiftAngle) > maxShiftAngle) || (abs(shiftDist) > maxShiftDist)){
	//		shiftAngle = maxShiftAngle * -1;	// Update for Negative values !!!!!!!!!
	//		shiftDist = maxShiftDist;
	//	}
	//}
	//if (shiftDist < 1.0){
		// Distance not worth doing just drive in
	//	shiftDist = 0;
	//	shiftAngle = 0;
	//}
	PutVisionData();
	Robot::vision->SetTipShiftData( shiftTotDist, shiftHdg1, shiftHdg2, shiftFwdDist );
	Robot::vision->SetTipShiftAnlges( shiftAngleA, shiftAngleB );
	Robot::vision->SetActiveWheel( shiftActiveWheelA, shiftActiveWheelB );
	LogVisionData();
}

// ------------------------ Get System Test Default Values --------------------
void VisionUpdate::GetVisionData(){
//	netTable = NetworkTable::GetTable("MyVisionData");
//	COGX = netTable->GetNumber("COG_X",0);
//	COGY = netTable->GetNumber("COG_Y",0);
	COGX = Robot::vision->GetUDPCOGX();
	COGY = Robot::vision->GetUDPCOGY();

}

// ------------------------ Get System Test Default Values --------------------
void VisionUpdate::PutVisionData(){
	netTable->PutNumber("COGX",COGX);
	netTable->PutNumber("COGY",COGY);
	netTable->PutNumber("angleX",angleX);
	netTable->PutNumber("currHdg",currHdg);
	netTable->PutNumber("tipHdg",tipHdg);
	netTable->PutNumber("tipAngle",tipAngle);
	netTable->PutNumber("tgtDist",tgtDist);
	netTable->PutNumber("tipDist",tipDist);
	netTable->PutNumber("shiftAngleA",shiftAngleA);
	netTable->PutNumber("shiftAngleB",shiftAngleB);
	netTable->PutNumber("shiftHdg1",shiftHdg1);
	netTable->PutNumber("shiftHdg2",shiftHdg2);
	netTable->PutNumber("shiftTotDist",shiftTotDist);
	netTable->PutNumber("shiftDistB",shiftDistB);
	netTable->PutNumber("shiftDistB",shiftDistB);
	netTable->PutNumber("shiftActiveWheelA",shiftActiveWheelA);
	netTable->PutNumber("shiftActiveWheelB",shiftActiveWheelB);
}

// *********************************************************************************
//                             Various Conversion Routines
// *********************************************************************************
void VisionUpdate::CalcProbTipHdg(double hdg, double alignError, double tgtCtrDist, double tgtCtrAngleX){
	// hdg = currhdg
	double angleA = tgtCtrAngleX + alignError;
	if (angleA < 0) angleA *= -1;
	double angleB = 90 - angleA;
	double sideb = tgtCtrDist * (cos(CnvrtDegToRad(angleA)));
	double sidec = tgtCtrDist * (sin(CnvrtDegToRad(angleA)));
	// sidec = shift dist
	shiftDist = sidec;																	// distance robot ctr is off tgt ctr must shift over
	double sidee = sideb - tgtDistFromWall;												// distance to tip from wall- decreased for greater accuracy
	double angleD = 90 - (CnvrtRadToDeg(atan(sidec / sidee)));
	double angleE = angleB - angleD;
	double newHdg;
	if (tgtCtrAngleX < 0)
		newHdg = hdg + angleX - angleE;									// Reveiw this for accuracy
	else
		newHdg = hdg + angleX + angleE;
	if (newHdg < 0) newHdg += 360;
	if (newHdg > 360) newHdg -=360;
	tipDist = sqrt((sidee * sidee) + (sidec * sidec));
	tipHdg=newHdg;
}

// --------------------------------------------------------------------------

void VisionUpdate::CalcMaxShiftData(double tipHdg, double tipDist){
	tipAngle = ConvertHdgToAngle(tipHdg - currHdg);
	double distTipBase = tipDist * cos(CnvrtDegToRad(tipAngle));				// distance forward to tip
	double tmpval = distTipBase / RADIUSROBOTMIDPT;
	if (tmpval > 1) tmpval = 1;
	maxShiftAngle = CnvrtRadToDeg(asin(tmpval));
	if (maxShiftAngle > 90) maxShiftAngle = 90;	// should not have to do this but .....
	if (abs(maxShiftAngle) == 90){
		maxShiftDist = RADIUSROBOTMIDPT * 2;
	} else {
		maxShiftDist = (RADIUSROBOTMIDPT * cos(CnvrtDegToRad(maxShiftAngle)) * 2);
	}
}
// --------------------------------------------------------------------------

void VisionUpdate::CalcShiftData(double tipHdg, double tipDist){
	tipAngle = ConvertHdgToAngle(tipHdg - currHdg);
	if (tipAngle < 0){
		// Target is Left of Robot Center so activate Right wheel then Left Wheel
		shiftActiveWheelA = +1;									// Right Wheel Drive on 1st turn
		shiftActiveWheelB = -1;									// Left  Wheel Drive on 2nd turn
	}
	else {
		// Target is Right of Robot Center so activate Left wheel then Right Wheel
		shiftActiveWheelA = -1;									// Left  Wheel Drive on 1st turn
		shiftActiveWheelB = +1;									// Right Wheel Drive on 2nd turn
	}
//	double robotAngle = tipAngle;



	double const WBCTR = 14;									// wheelbase Ctr Distance

	//if (distShift > 20) distShift = 20;							// This is the max the robot can shift in an S curve
	double w = WBCTR;
	double theta = tgtAlignError;
	double l = shiftDist;
	double tmp2 = w + ( w * (cos(CnvrtDegToRad(theta)))) - l;
	double tmp3 = tmp2 / (2*w);
	double tmp4 = CnvrtRadToDeg(acos(tmp3));
	shiftAngleB = tmp4;
	shiftAngleA = (shiftAngleB - tgtAlignError);								// returns positive always
	shiftDistB = WBCTR - (WBCTR * (cos(CnvrtDegToRad(shiftAngleB))));
	shiftDistA = shiftDist - shiftDistB;
	if (tipAngle < 0){
		shiftAngleA *= -1;		// were starting with a right turn the left turn
	}
	else {
		shiftAngleB *= -1;		// were starting with a left turn then right turn
	}
	shiftHdg1 = AddAngleToHdg(currHdg,  shiftAngleA);
	shiftHdg2 =  AddAngleToHdg(shiftHdg1, shiftAngleB);
	shiftTotDist = shiftDist;
	shiftFwdDist = 0;


	line = "Debug, Vision Update (***In Calc Routine****), ";
	line += " ,tmp2 =" +  std::to_string(tmp2);
	line += " ,tmp3 =" +  std::to_string(tmp3);
	line += " ,tmp4 =" +  std::to_string(tmp4);
	line += ",tipAngle =" +  std::to_string(tipAngle);
	line += " ,tipDist=" +  std::to_string(tipDist);
	line += " ,tipHdg=" +  std::to_string(tipHdg);
	line += " ,shiftAngleAB=" +  std::to_string(shiftAngleA) + " ," +  std::to_string(shiftAngleB);
	line += " ,shiftHdg12=" +  std::to_string(shiftHdg1) + ", " +  std::to_string(shiftHdg2);
	line += " ,shiftTotDist=" +  std::to_string(shiftTotDist);
	line += " ,shiftDistAB=" +  std::to_string(shiftDistA) + ", " +  std::to_string(shiftDistB);
	line += " ,shiftActiveWheelAB=" +  std::to_string(shiftActiveWheelA) + ", " +  std::to_string(shiftActiveWheelB);
	Robot::logger->appendLog(line);
	return;
}

// --------------------------------------------------------------------------

void VisionUpdate::LogVisionData(){
	line = "Debug, Vision, ";
	line += ",COGXY =" +  std::to_string(COGX) + "," +std::to_string(COGY) ;
	line += ",currHdg =" +  std::to_string(currHdg);
	line += ",angleX =" +  std::to_string(angleX);
	line += ",htAngle =" +  std::to_string(htAngle);
	line += ",tgtDist =" +  std::to_string(tgtDist);
	line += ",tipAngle =" +  std::to_string(tipAngle);
	line += " ,tipHdg=" +  std::to_string(tipHdg);
	line += " ,tipDist=" +  std::to_string(tipDist);
//	line += " ,maxShiftDist=" + std::to_string(maxShiftDist);
//	line += " ,maxShiftAngle=" + std::to_string(maxShiftAngle);
	line += " ,shiftAngleAB=" +  std::to_string(shiftAngleA) + " ," +  std::to_string(shiftAngleB);
	line += " ,shiftHdg12=" +  std::to_string(shiftHdg1) + ", " +  std::to_string(shiftHdg2);
	line += " ,shiftTotDist=" +  std::to_string(shiftTotDist);
	line += " ,shiftDistAB=" +  std::to_string(shiftDistA) + ", " +  std::to_string(shiftDistB);
	line += " ,shiftActiveWheelAB=" +  std::to_string(shiftActiveWheelA) + ", " +  std::to_string(shiftActiveWheelB);
	Robot::logger->appendLog(line);
}

// --------------------------------------------------------------------------
//                             Image Angle/Pixle Conversions
// --------------------------------------------------------------------------
float VisionUpdate::ConvertImageAngleToPixelCnt(float angle, float ctr){
	float pos=0;
	pos = (angle / DEGPERPIXLE) + ctr;
	return (Round(pos, 0));
}

float VisionUpdate::ConvertImagePosToAngle(float pos, float ctr ){
	// returns < 0 = left of Ctr,  > 0 = right of Ctr
	float angle;
	angle = ( pos - ctr ) * DEGPERPIXLE;
	return (angle);
}

float VisionUpdate::CnvrtDegToRad(float degree){
	float rad = degree * DEGREETORADIANCONST;
	return rad;
}

float VisionUpdate::CnvrtRadToDeg(float radian){
	float deg = RADIANSTODEGREECONST * radian;
	return deg;
}

// --------------------------------------------------------------------------
//                      Heading Angle Routines
// --------------------------------------------------------------------------
float VisionUpdate::AddAngleToHdg(double currHdg, double angle){
	return  ConstrainDeg0To360(currHdg + angle);
}

double VisionUpdate::ConvertHdgToAngle(double hdg){
	double angle = hdg;
	if (hdg > 180)  angle -= 360;
	if (hdg < -180)	angle += 360;
	return  angle;
}
double VisionUpdate::ConvertAngleToHdg(double angle){
	double tempHdg;
	if (angle >= 0){
		tempHdg = angle;
	}
	else {
		tempHdg = angle + 360;
	}
	return ConstrainDeg0To360(tempHdg);
}

double VisionUpdate::ConstrainDeg0To360(double deg){
	while (deg > 360) 	{ deg -= 360; }
	while (deg < 0)		{ deg += 360; }
	return deg;
}
double VisionUpdate::ConstrainDeg0To180(double deg){
	return ConstrainDeg0To360(deg + 180) - 180;
}

float VisionUpdate::Round(float value, int digits){
	int mult = 1;
	if (digits == 0) mult = 1;
	else if (digits == 1) mult = 10;
	else if (digits == 2) mult = 100;
	else if (digits == 3) mult = 1000;
	else if (digits == 4) mult = 10000;
	else if (digits == 5) mult = 100000;
	else if (digits == 6) mult = 1000000;
	return (round(value * mult) / mult);
}


// Make this return true when this Command no longer needs to run execute()
bool VisionUpdate::IsFinished() {
    return true;
}

// Called once after isFinished returns true
void VisionUpdate::End() {
	std::cout << "End vision update Cmd" << std::endl;
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void VisionUpdate::Interrupted() {

}



