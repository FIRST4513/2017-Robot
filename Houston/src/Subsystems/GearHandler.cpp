// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "GearHandler.h"
#include "../RobotMap.h"
#include "../Commands/GearDefaultCmd.h"


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

GearHandler::GearHandler() : Subsystem("GearHandler") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    gearEjectSpike = RobotMap::gearHandlerGearEjectSpike;
    gearRotSpike = RobotMap::gearHandlerGearRotSpike;
    gearEjectFwdLmtSw = RobotMap::gearHandlerGearEjectFwdLmtSw;
    gearEjectRearLmtSw = RobotMap::gearHandlerGearEjectRearLmtSw;
    gearTransPot = RobotMap::gearHandlerGearTransPot;
    gearTransLeftLmtSw = RobotMap::gearHandlerGearTransLeftLmtSw;
    gearRotateSnsr = RobotMap::gearHandlerGearRotateSnsr;
    gearTransRightLmtSw = RobotMap::gearHandlerGearTransRightLmtSw;
    gearLoadedSnsr = RobotMap::gearHandlerGearLoadedSnsr;
    gearTransSpdCtrl = RobotMap::gearHandlerGearTransSpdCtrl;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}

void GearHandler::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new GearDefaultCmd());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}


// Put methods for controlling this subsystem
// here. Call these from Commands.


// --------------- Motor Control -----------------
void GearHandler::TransMtrDrive(double speed){
	// speed < 0 moves left    speed > 0 move right
	if ((speed < 0) && (gearTransLeftLmtSw->Get() == NOTPRESSED)) {
				gearTransSpdCtrl->Set(-speed);
	} else if ((speed > 0) && (gearTransRightLmtSw->Get() == NOTPRESSED)) {
				gearTransSpdCtrl->Set(-speed);
		        //gearTransSpike->Set(gearTransSpike->kOn);
	} else {
				gearTransSpdCtrl->Set(0); }
}

void GearHandler::TransMtrOff(){
	gearTransSpdCtrl->Set(0);
}
void GearHandler::RotateMtrOn(){
	gearRotSpike->Set(gearRotSpike->kForward);
}
void GearHandler::RotateMtrOff(){
	gearRotSpike->Set(gearRotSpike->kOff);
}
void GearHandler::EjectMotorFwd(){
	gearEjectSpike->Set(gearEjectSpike->kForward);
}

void GearHandler::EjectMotorBack(){
	gearEjectSpike->Set(gearEjectSpike->kReverse);
}
void GearHandler::EjectMotorStop(){
	gearEjectSpike->Set(gearEjectSpike->kOff);
}

// ---------------- Limit Switch Methods ---------------
bool GearHandler::GetTransLeftLmtSw(){
	if (gearTransLeftLmtSw->Get() == PRESSED) return true;
	return false;
}
bool GearHandler::GetTransRightLmtSw(){
	if (gearTransRightLmtSw->Get() == PRESSED) return true;
	return false;
}
bool GearHandler::GetEjectFwdLmtSw(){
	if (gearEjectFwdLmtSw->Get() == PRESSED) return true;
	return false;
}
bool GearHandler::GetEjectRearLmtSw(){
	if (gearEjectRearLmtSw->Get() == PRESSED) return true;
	return false;
}
bool GearHandler::GetGearInHopperSnsr(){
	if ( gearLoadedSnsr->Get() == GEARINHOPPER) return true;
	return false;
}
bool GearHandler::GetGearAlignedSnsr(){
	if ( gearRotateSnsr->Get() == GEARALIGNED) return true;
	return false;
}

// -------- Pot Methods ---------------
//void SetPotDefaults(float kPotOffset, float kPotScale);
float GearHandler::GetTransPosition(){
	// return >0 if right of ctr < 0 if left of ctr
	double currPotVolt = GetTransPotValue();
	double convConst = (k_PotRightVolt - k_PotLeftVolt) / k_GearTransWidth;
	return (currPotVolt - k_PotCtrVolt ) / convConst;
}

float GearHandler::GetTransPotValue(){
	return (gearTransPot->Get());
}


// ------------------- Misc Methods ------------------------
void GearHandler::PutGearAutoAlignFlag(bool flag){

}
bool GearHandler::GetAutoAlignFlag(){
	return 0;
}
void GearHandler::DisplaySmartdashValues(){
}

void GearHandler::DisplaySmartdashSimple(){

	// ----------- Translate Motor Limit Switches -------
	if (gearTransLeftLmtSw->Get() == PRESSED)
		SmartDashboard::PutString("TransLeft LmtSw", "Pressed");
	else
		SmartDashboard::PutString("TransLeft LmtSw", "NOT Pressed");

	if (gearTransRightLmtSw->Get() == PRESSED)
		SmartDashboard::PutString("TransRight LmtSw", "Pressed");
	else
		SmartDashboard::PutString("TransRight LmtSw", "NOT Pressed");

	// ----------- Eject Motor Limit Switches -------
	if (gearEjectFwdLmtSw->Get() == PRESSED)
		SmartDashboard::PutString("Eject Fwd LmtSw", "Pressed");
	else
		SmartDashboard::PutString("Eject Fwd LmtSw", "NOT Pressed");

	if (gearEjectRearLmtSw->Get() == PRESSED)
		SmartDashboard::PutString("Eject Rear LmtSw", "Pressed");
	else
		SmartDashboard::PutString("Eject Rear LmtSw", "NOT Pressed");

	// ----------- Gear Hopper Sensors -------
	if (gearLoadedSnsr->Get() == GEARINHOPPER)
		SmartDashboard::PutString("Gear Hopper", "Loaded");
	else
		SmartDashboard::PutString("Gear Hopper", "empty");

	if (gearRotateSnsr ->Get() == GEARALIGNED)
		SmartDashboard::PutString("Gear RotSnsr", "Not Aligned");
	else
		SmartDashboard::PutString("Gear RotSnsr", "Aligned");

	// ----------- Gear Translate Pot Values -------
	SmartDashboard::PutNumber("Trans Pot Pos",Round(GetTransPosition(),3));
	SmartDashboard::PutNumber("Trans Pot Value",Round(GetTransPotValue(),4));
}

double GearHandler::Round(double value, int digits){
	int mult = 1;
	if (digits == 0) mult = 1;
	else if (digits == 1) mult = 10;
	else if (digits == 2) mult = 100;
	else if (digits == 3) mult = 1000;
	else if (digits == 4) mult = 10000;
	else if (digits == 5) mult = 100000;
	else if (digits == 6) mult = 1000000;
	return (round(value * mult) / mult);
}

