// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "Logger.h"
#include "../RobotMap.h"
#include "../Robot.h"
#include "../Commands/LoggingCmd.h"


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Logger::Logger() : Subsystem("Logger") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	Logger::createFile();
	Logger::startTime();
	Logger::mode = TELE;
	LogFlag = 1;		// Start with detail logging turned off 1=on
	time = lastTime = leftLastDist = rightLastDist = avgLastDist = 0;
	lastPotPos = -9999;
	pdp = new PowerDistributionPanel();
}

void Logger::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new LoggingCmd());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}


// ------------------------------------------------------------------------
// ------------------------- Subsystem Methods ----------------------------
void Logger::createFile(){
	printf("Logger Creating file");
	std::string last = base + "10.txt";
	std::string current;
	remove(last.c_str());
	for (int i = 9; i > 0; i--){
		current = base + std::to_string(i)+".txt";
		rename (current.c_str(), last.c_str());
		last = current;
	}
	outFile.open(last.c_str());
	if(!outFile){
		std::cout << "ERROR: log file not created at " << last << std::endl;
	}
	outFile << "Log File Created" << std::endl;
}


void Logger::startTime(){
	timer.Reset();
	timer.Start();
}

void Logger::appendLog(std::string s){
	time = timer.Get();
//	time = (mode == TELE)?(time+15):(time);
	lines.push_back(std::to_string(time)+", " + s);
}

void Logger::appendLog(std::string s, double d){
	time = timer.Get();
//	time = (mode == TELE)?(time+15):(time);
	lines.push_back(std::to_string(time)+", " + s + ", " + std::to_string(d));
}

void Logger::appendLog(std::string type, std::string sys, std::string s ){
	time = timer.Get();
	lines.push_back(std::to_string(time)+", " + type + ", " + sys + ", " + s);
}

void Logger::logDrivetrain(){
	double leftCnt, rightCnt;
	double leftDist, rightDist, avgDist;
	double leftSpeed, rightSpeed, avgSpeed;
	double leftIRDist, rightIRDist, USDist;

	time = Robot::drivetrain->lastTime;

	// ---- Get Encoder Cnts -------
	leftCnt = Robot::drivetrain->GetLeftEnc();
	rightCnt = Robot::drivetrain->GetRightEnc();

	// ---- Calc Distances ----
	leftDist = Robot::drivetrain->GetLeftDist();
	rightDist = Robot::drivetrain->GetRightDist();
	avgDist = Robot::drivetrain->GetAverageDist();
	leftIRDist = Robot::drivetrain->GetLeftProxDistance();
	rightIRDist =  Robot::drivetrain->GetRightProxDistance();
	USDist = Robot::drivetrain->GetSonarDistance();

	// ---- Get Motor Speeds ----
	leftSpeed = Robot::drivetrain->GetLeftSpeed();
	rightSpeed = Robot::drivetrain->GetRightSpeed();
	avgSpeed = Robot::drivetrain->GetAverageSpeed();

	// ----------- Check to see if we have motion if not Exit ----------------
	if ((rightSpeed == 0) && (leftSpeed == 0)) return;	// No motion so don't send line out

	// ---------- Build Print String -----------------
	line = std::to_string(time) + ", Debug, Drivetrain";
	line += ",TgtRemainDist=," + std::to_string(Robot::drivetrain->GetTgtRemainDist());

	line += " ,Drive Mode=," + std::to_string(Robot::drivetrain->MotorMode);

	line += " ,Tank LR=," + std::to_string(Robot::drivetrain->MotorLeft) + "," +
							std::to_string(Robot::drivetrain->MotorRight);
	line += " ,CurrPwr LR=," + std::to_string(Robot::drivetrain->left.currPwr) + "," +
							   std::to_string(Robot::drivetrain->right.currPwr);

	line += " ,Drive SA=," + std::to_string(Robot::drivetrain->MotorSpeed) + "," +
							 std::to_string(Robot::drivetrain->MotorAngle);

	line += " ,Enc-LR=,"    + std::to_string(leftCnt)  + "," + std::to_string(rightCnt);
	line += " ,Dist-LRA=,"  + std::to_string(leftDist) + "," + std::to_string(rightDist) + "," +
							  std::to_string(avgDist);
	line += " ,Speed-LRA=," + std::to_string(leftSpeed) + "," +std::to_string(rightSpeed) + "," +
							  std::to_string(avgSpeed);

	line += " FrontLftPwr=" + std::to_string( pdp->GetCurrent(12));
	line += " RearLeftPwr=" + std::to_string( pdp->GetCurrent(14));
	line += " FrontRightPwr=" + std::to_string( pdp->GetCurrent(15));
	line += " RearRightPwr=" + std::to_string( pdp->GetCurrent(13));
	line += " BatVolt=" + std::to_string(pdp->GetVoltage());

	line += " ,GyroHdg=," + std::to_string(Robot::drivetrain->GetGyroHeading());
	line += " ,GyroYaw=," + std::to_string(Robot::drivetrain->GetGyroYaw());
	line += " ,Correction=," + std::to_string(Robot::drivetrain->GetCorrection());


	line += " ,Vision Flg=," + std::to_string(Robot::vision->GetValidTgtFlag());
	line +=" ,Vision Dist=," + std::to_string(Robot::vision->GetTgtDist());
	line +=" ,VisionTrans=," + std::to_string(Robot::vision->GetTgtTransCorrection());

	line += " ,Vision UDPCOGXY=," + std::to_string(Robot::vision->GetUDPCOGX()) + ", " +
						   		 	std::to_string(Robot::vision->GetUDPCOGX());
	line += " ,Vision TipHdg=," + std::to_string(Robot::vision->GetTipHdg());
	line += " ,Vision TipDist=," + std::to_string(Robot::vision->GetTipDist());

	line += " ,IR Prox-LR Dist=," + std::to_string(leftIRDist) + "," + std::to_string(rightIRDist);

	line += " ,US Dist=," + std::to_string(USDist);
	if (Robot::drivetrain->GetProbeLmtSw() == false)
		line += " ,Probe=,False,";
	else
		line += " ,Probe=,True,";

	// ---- send line to buffer ---------
	lines.push_back(line);
}

void Logger::logJoyAxis(std::shared_ptr<frc::Joystick> joy){
	time = timer.Get();
	line = std::to_string(time) + ", Debug, Joystick";
	line += ", Xaxis=," + std::to_string(Robot::drivetrain->JoyXaxis);
	line += ", Yaxis=," + std::to_string(Robot::drivetrain->JoyYaxis);
	line += ", Twist=," + std::to_string(Robot::drivetrain->JoyTwist);
	line += ", Throttle=," + std::to_string(Robot::drivetrain->JoyThrottle);
	line += ", RevBtn=," + std::to_string(Robot::drivetrain->JoyReverse);
	lines.push_back(line);
}

void Logger::logGearHandler(){
	double potVal = Round(Robot::gearHandler->GetTransPotValue(),2);
	double potPos = Round(Robot::gearHandler->GetTransPosition(),1);
	if (potVal < 0.5) return;			// No connection

	if (lastPotPos == potPos) return;	// NO change
	lastPotPos = potPos;

	time = timer.Get();
	line = std::to_string(time) + ", Debug, GearHandler";
	line += ", Pos=," + std::to_string(potPos);
	line += ", Pot=," + std::to_string(potVal);
	line += ", LtLmt=," + std::to_string(Robot::gearHandler->GetTransLeftLmtSw());
	line += ", RtLmt=," + std::to_string(Robot::gearHandler->GetTransRightLmtSw());
	lines.push_back(line);
}

void Logger::setLogFlag(double flag){
	LogFlag = flag;
}

double Logger::getLogFlag(){
	return LogFlag;
}

void Logger::printLog(){
	printf("Logger printlog function called");
	std::vector<std::string>::iterator it;
	for (it = lines.begin(); it != lines.end(); ++it){
		outFile << (*it).c_str() << std::endl;
	}
	lines.clear();
}

void Logger::clearLog(){
	lines.clear();
}

double Logger::Round(double value, int digits){
	int mult = 1;
	if (digits == 0) mult = 1;
	else if (digits == 1) mult = 10;
	else if (digits == 2) mult = 100;
	else if (digits == 3) mult = 1000;
	else if (digits == 4) mult = 10000;
	else if (digits == 5) mult = 100000;
	else if (digits == 6) mult = 1000000;
	return (round(value * mult) / mult);
}

